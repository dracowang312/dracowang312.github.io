<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"draco.wang","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":"truw","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C#（读作C Sharp）是一种由微软开发的通用、面向对象的编程语言。它结合了C和C++语言的强大功能，同时又去掉了一些繁琐的特性，使得编程更加简单和高效。">
<meta property="og:type" content="article">
<meta property="og:title" content="Csharp">
<meta property="og:url" content="https://draco.wang/Csharp/index.html">
<meta property="og:site_name" content="王小龙的博客">
<meta property="og:description" content="C#（读作C Sharp）是一种由微软开发的通用、面向对象的编程语言。它结合了C和C++语言的强大功能，同时又去掉了一些繁琐的特性，使得编程更加简单和高效。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-01T16:00:00.000Z">
<meta property="article:modified_time" content="2024-06-13T06:39:04.691Z">
<meta property="article:author" content="王小龙">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://draco.wang/Csharp/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://draco.wang/Csharp/","path":"Csharp/","title":"Csharp"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Csharp | 王小龙的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">王小龙的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#NET-Framework%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">.NET Framework入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CLR-%E5%85%AC%E5%85%B1%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="nav-number">1.1.</span> <span class="nav-text">CLR(公共语言运行时)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FCL-%E7%BB%9F%E4%B8%80%E7%9A%84%E7%B1%BB%E5%BA%93%E9%9B%86"><span class="nav-number">1.2.</span> <span class="nav-text">FCL(统一的类库集)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%E5%92%8C%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">特点和功能：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%9A%84%E8%9E%8D%E5%90%88"><span class="nav-number">1.4.</span> <span class="nav-text">多语言的融合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">语言无关性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAc-%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.6.</span> <span class="nav-text">第一个c#程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">1.7.</span> <span class="nav-text">配置环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Macos%E4%B8%8A%E9%85%8D%E7%BD%AEdotnet"><span class="nav-number">1.8.</span> <span class="nav-text">Macos上配置dotnet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.9.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E6%96%B9%E6%B3%95%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%99%E6%B3%95"><span class="nav-number">1.10.</span> <span class="nav-text">main方法的四种写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%AB%E4%B9%89"><span class="nav-number">1.11.</span> <span class="nav-text">项目下的文件含义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">两种数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">常用的基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Datetime"><span class="nav-number">2.3.</span> <span class="nav-text">Datetime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.4.</span> <span class="nav-text">隐式类型转换&#x2F;自动类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.5.</span> <span class="nav-text">显式类型转换&#x2F;强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.6.</span> <span class="nav-text">值类型和引用类型的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="nav-number">2.7.</span> <span class="nav-text">装箱和拆箱</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">变量和常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">3.2.</span> <span class="nav-text">变量的命名规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">定义变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.4.</span> <span class="nav-text">定义变量的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#var%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.5.</span> <span class="nav-text">var关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">3.6.</span> <span class="nav-text">常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">4.</span> <span class="nav-text">格式化输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%AC%A6"><span class="nav-number">4.1.</span> <span class="nav-text">连接符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-number">4.2.</span> <span class="nav-text">转义字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="nav-number">4.3.</span> <span class="nav-text">占位符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.4.</span> <span class="nav-text">插值表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Console%E7%B1%BB"><span class="nav-number">4.5.</span> <span class="nav-text">Console类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.1.</span> <span class="nav-text">一元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.2.</span> <span class="nav-text">二元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.3.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.4.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E8%B7%AF%E6%93%8D%E4%BD%9C"><span class="nav-number">5.5.</span> <span class="nav-text">短路操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.6.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.7.</span> <span class="nav-text">三元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">5.8.</span> <span class="nav-text">运算符的优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">顺序结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">判断结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.</span> <span class="nav-text">循环结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">7.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.1.</span> <span class="nav-text">数组的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">定义方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="nav-number">7.3.</span> <span class="nav-text">如何访问数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="nav-number">7.4.</span> <span class="nav-text">数组的典型应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">7.5.</span> <span class="nav-text">二维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="nav-number">7.6.</span> <span class="nav-text">交错数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">8.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">8.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="nav-number">8.2.</span> <span class="nav-text">定义枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="nav-number">8.3.</span> <span class="nav-text">使用枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.4.</span> <span class="nav-text">枚举的底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">9.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-number">9.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text">特点和用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">10.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="nav-number">10.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">10.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.3.</span> <span class="nav-text">实例化对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">10.4.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">10.5.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">10.6.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">11.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="nav-number">11.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">11.2.</span> <span class="nav-text">方法的调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="nav-number">11.3.</span> <span class="nav-text">递归调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOP%E6%80%9D%E6%83%B3"><span class="nav-number">11.4.</span> <span class="nav-text">OOP思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#return"><span class="nav-number">11.5.</span> <span class="nav-text">return</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">11.6.</span> <span class="nav-text">方法的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.7.</span> <span class="nav-text">关于方法参数的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">11.8.</span> <span class="nav-text">参数的修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">11.9.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">11.10.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E5%BC%95%E7%94%A8%E5%BC%82%E5%B8%B8"><span class="nav-number">11.11.</span> <span class="nav-text">空引用异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">12.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="nav-number">12.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">12.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="nav-number">13.</span> <span class="nav-text">索引器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-6"><span class="nav-number">13.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">13.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">14.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-7"><span class="nav-number">14.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">14.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#base%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">14.3.</span> <span class="nav-text">base关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">15.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-8"><span class="nav-number">15.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="nav-number">15.2.</span> <span class="nav-text">里氏替换原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-number">15.3.</span> <span class="nav-text">构造方法的多态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-abstract"><span class="nav-number">15.4.</span> <span class="nav-text">抽象方法 abstract</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual%E8%99%9A%E6%96%B9%E6%B3%95"><span class="nav-number">15.5.</span> <span class="nav-text">virtual虚方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">16.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-9"><span class="nav-number">16.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">16.2.</span> <span class="nav-text">接口的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">16.3.</span> <span class="nav-text">接口的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">16.4.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="nav-number">17.</span> <span class="nav-text">字符串方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-10"><span class="nav-number">17.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">17.2.</span> <span class="nav-text">创建字符串的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">17.3.</span> <span class="nav-text">String的常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">17.4.</span> <span class="nav-text">StringBuilder可变字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">18.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-11"><span class="nav-number">18.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9%E8%B1%A1"><span class="nav-number">18.2.</span> <span class="nav-text">创建正则表达式对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">18.3.</span> <span class="nav-text">匹配字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C"><span class="nav-number">18.4.</span> <span class="nav-text">获取匹配结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%89%80%E6%9C%89%E5%8C%B9%E9%85%8D"><span class="nav-number">18.5.</span> <span class="nav-text">查找所有匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">18.6.</span> <span class="nav-text">替换匹配的字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-number">19.</span> <span class="nav-text">调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">19.1.</span> <span class="nav-text">错误类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="nav-number">19.2.</span> <span class="nav-text">断点调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">20.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-12"><span class="nav-number">20.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">20.2.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="nav-number">20.3.</span> <span class="nav-text">异常体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">20.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throw%E5%BC%95%E5%8F%91%E5%BC%82%E5%B8%B8"><span class="nav-number">20.5.</span> <span class="nav-text">throw引发异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">21.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-13"><span class="nav-number">21.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%EF%BC%88Generic-Collections%EF%BC%89"><span class="nav-number">21.2.</span> <span class="nav-text">泛型集合（Generic Collections）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%EF%BC%88Non-generic-Collections%EF%BC%89"><span class="nav-number">21.3.</span> <span class="nav-text">非泛型集合（Non-generic Collections）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList"><span class="nav-number">21.4.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E7%89%B9%E6%80%A7%E5%92%8C%E7%94%A8%E9%80%94"><span class="nav-number">21.5.</span> <span class="nav-text">ArrayList特性和用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E7%A4%BA%E4%BE%8B"><span class="nav-number">21.6.</span> <span class="nav-text">ArrayList示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">21.7.</span> <span class="nav-text">HashTable 哈希表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">22.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-14"><span class="nav-number">22.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">22.2.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">22.3.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">22.4.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="nav-number">22.5.</span> <span class="nav-text">泛型约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%BC%98%E5%8A%BF"><span class="nav-number">22.6.</span> <span class="nav-text">泛型优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">22.7.</span> <span class="nav-text">泛型应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%EF%BC%9AList"><span class="nav-number">22.8.</span> <span class="nav-text">泛型集合：List&lt;&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E5%AE%9A%E4%B9%89"><span class="nav-number">22.9.</span> <span class="nav-text">List&lt;&gt;定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">22.10.</span> <span class="nav-text">List&lt;&gt; 的创建和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="nav-number">22.11.</span> <span class="nav-text">添加和访问元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-number">22.12.</span> <span class="nav-text">判断元素是否存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">22.13.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-List-%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">22.14.</span> <span class="nav-text">获取 List 的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-List"><span class="nav-number">22.15.</span> <span class="nav-text">遍历 List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA-List"><span class="nav-number">22.16.</span> <span class="nav-text">清空 List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%EF%BC%9ADictionary"><span class="nav-number">22.17.</span> <span class="nav-text">泛型集合：Dictionary&lt;&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-15"><span class="nav-number">22.18.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dictionary-%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">22.19.</span> <span class="nav-text">Dictionary 的创建和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%92%8C%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-1"><span class="nav-number">22.20.</span> <span class="nav-text">添加和访问元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-number">22.21.</span> <span class="nav-text">判断键是否存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1"><span class="nav-number">22.22.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Dictionary-%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">22.23.</span> <span class="nav-text">获取 Dictionary 的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-Dictionary-%E4%B8%AD%E7%9A%84%E9%94%AE%E5%92%8C%E5%80%BC"><span class="nav-number">22.24.</span> <span class="nav-text">获取 Dictionary 中的键和值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%A9%BA-Dictionary"><span class="nav-number">22.25.</span> <span class="nav-text">清空 Dictionary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A7%94%E6%89%98"><span class="nav-number">23.</span> <span class="nav-text">委托</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-16"><span class="nav-number">23.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">23.2.</span> <span class="nav-text">委托的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E5%A4%9A%E6%92%AD"><span class="nav-number">23.3.</span> <span class="nav-text">委托的多播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">23.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">24.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">24.1.</span> <span class="nav-text">事件的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">24.2.</span> <span class="nav-text">事件的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="nav-number">24.3.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">24.4.</span> <span class="nav-text">事件的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number">25.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84-I-O-%E6%B5%81%E7%B1%BB"><span class="nav-number">25.1.</span> <span class="nav-text">主要的 I&#x2F;O 流类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileStream"><span class="nav-number">25.2.</span> <span class="nav-text">FileStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileStream%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%B9%B6%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">25.3.</span> <span class="nav-text">FileStream创建文件并写入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileStream%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%B9%B6%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">25.4.</span> <span class="nav-text">FileStream打开文件并读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileStream%E8%BF%BD%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E7%8E%B0%E6%9C%89%E6%96%87%E4%BB%B6"><span class="nav-number">25.5.</span> <span class="nav-text">FileStream追加数据到现有文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FileStream%E5%88%A0%E9%99%A4%E7%8E%B0%E6%9C%89%E6%96%87%E4%BB%B6"><span class="nav-number">25.6.</span> <span class="nav-text">FileStream删除现有文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StreamReader"><span class="nav-number">25.7.</span> <span class="nav-text">StreamReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StreamWrite"><span class="nav-number">25.8.</span> <span class="nav-text">StreamWrite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">25.9.</span> <span class="nav-text">File类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Directory%E7%B1%BB"><span class="nav-number">25.10.</span> <span class="nav-text">Directory类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">25.11.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">26.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">26.1.</span> <span class="nav-text">二进制序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">26.2.</span> <span class="nav-text">二进制反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">26.3.</span> <span class="nav-text">XML序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">26.4.</span> <span class="nav-text">XML反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">26.5.</span> <span class="nav-text">JSON 序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">26.6.</span> <span class="nav-text">JSON 反序列化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">27.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84%E5%8F%8D%E5%B0%84%E7%B1%BB"><span class="nav-number">27.1.</span> <span class="nav-text">主要的反射类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">27.2.</span> <span class="nav-text">使用反射的场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E5%92%8C%E6%88%90%E5%91%98%E4%BF%A1%E6%81%AF"><span class="nav-number">27.3.</span> <span class="nav-text">示例：使用反射获取类型信息和成员信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">28.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">28.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">28.2.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CancellationToken"><span class="nav-number">28.3.</span> <span class="nav-text">CancellationToken</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Task"><span class="nav-number">28.4.</span> <span class="nav-text">Task</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-3-0%E4%B8%AD%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="nav-number">29.</span> <span class="nav-text">C#3.0中新语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">29.1.</span> <span class="nav-text">自动属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E5%92%8C%E9%9B%86%E5%90%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="nav-number">29.2.</span> <span class="nav-text">对象初始化器和集合初始化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8FVar"><span class="nav-number">29.3.</span> <span class="nav-text">隐式类型变量Var</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">29.4.</span> <span class="nav-text">匿名类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="nav-number">29.5.</span> <span class="nav-text">拓展方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">30.</span> <span class="nav-text">Lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">30.0.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="nav-number">30.0.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="nav-number">30.1.</span> <span class="nav-text">表达式树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="nav-number">30.1.1.</span> <span class="nav-text">创建表达式树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="nav-number">30.1.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="nav-number">30.2.</span> <span class="nav-text">Lambda 表达式详细解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%95%E5%8F%82%E6%95%B0Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">30.2.1.</span> <span class="nav-text">1. 单参数Lambda表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%9A%E5%8F%82%E6%95%B0Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">30.2.2.</span> <span class="nav-text">2. 多参数Lambda表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">30.2.3.</span> <span class="nav-text">3. 没有参数的Lambda表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%85%B7%E6%9C%89%E8%AF%AD%E5%8F%A5%E5%9D%97%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">30.2.4.</span> <span class="nav-text">4. 具有语句块的Lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="nav-number">30.3.</span> <span class="nav-text">表达式树详细解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="nav-number">30.3.1.</span> <span class="nav-text">1. 创建简单的表达式树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%86%E6%9E%90%E5%A4%8D%E6%9D%82%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="nav-number">30.3.2.</span> <span class="nav-text">2. 分析复杂表达式树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">30.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="王小龙"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">王小龙</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://draco.wang/Csharp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王小龙">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王小龙的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Csharp | 王小龙的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Csharp
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-02T00:00:00+08:00">2024-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-13 14:39:04" itemprop="dateModified" datetime="2024-06-13T14:39:04+08:00">2024-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>C#（读作C Sharp）是一种由微软开发的通用、面向对象的编程语言。它结合了C和C++语言的强大功能，同时又去掉了一些繁琐的特性，使得编程更加简单和高效。</p>
<span id="more"></span>

<h2 id="NET-Framework入门"><a href="#NET-Framework入门" class="headerlink" title=".NET Framework入门"></a>.NET Framework入门</h2><p>.NET Framework 是微软开发的一个面向对象的软件开发框架，用于构建各种类型的应用程序，包括桌面应用、Web 应用、服务、库以及移动应用。它提供了一系列的类库和运行时环境，使得开发人员能够更快速、更简单地开发和部署应用程序。</p>
<h3 id="CLR-公共语言运行时"><a href="#CLR-公共语言运行时" class="headerlink" title="CLR(公共语言运行时)"></a>CLR(公共语言运行时)</h3><p>CLR（Common Language Runtime，公共语言运行时）是 .NET Framework 的核心组件之一，它提供了一个统一的运行时环境，用于执行 .NET 应用程序。CLR 负责管理 .NET 应用程序的执行过程，并提供了许多重要的功能和服务，包括：</p>
<p><strong>即时编译（Just-In-Time Compilation，JIT）：</strong> CLR 包含了一个即时编译器，它将中间语言（IL）代码转换为特定平台的本机机器代码。这样，CLR 可以在运行时将 IL 代码编译成可执行的代码，并在处理器上执行。</p>
<p><strong>内存管理：</strong> CLR 负责管理应用程序的内存分配和释放。它包含了一个垃圾回收器（Garbage Collector，GC），用于自动回收不再使用的对象，并释放它们所占用的内存。这样，开发人员无需手动管理内存，可以避免内存泄漏和资源泄漏。</p>
<p><strong>异常处理：</strong> CLR 提供了强大的异常处理机制，用于捕获和处理应用程序中的异常情况。开发人员可以使用 try-catch-finally 块来捕获和处理异常，确保应用程序的稳定性和可靠性。</p>
<p><strong>安全性：</strong> CLR 实施了严格的安全性机制，用于保护应用程序免受恶意代码的攻击和破坏。它包含了代码访问安全性（CAS）、代码验证、代码签名等机制，确保应用程序在安全的环境中运行。</p>
<p><strong>类型系统和元数据：</strong> CLR 包含了一个强大的类型系统和元数据系统，用于描述和管理应用程序中的类型和成员。它支持面向对象编程的特性，如封装、继承、多态等，并提供了丰富的类型库和类库，帮助开发人员构建高质量的应用程序。</p>
<p><strong>多语言互操作性：</strong> CLR 支持多种编程语言的开发，并提供了一致的运行时环境和类型系统，使得不同语言编写的程序可以互相调用和交互。这样，开发人员可以根据自己的喜好和需求选择最适合的编程语言进行开发。</p>
<p>总的来说，CLR 是 .NET Framework 的核心组件，它为 .NET 应用程序提供了一个统一的运行时环境和执行引擎，提供了许多重要的功能和服务，帮助开发人员构建高质量、可靠性和安全性的应用程序。</p>
<h3 id="FCL-统一的类库集"><a href="#FCL-统一的类库集" class="headerlink" title="FCL(统一的类库集)"></a>FCL(统一的类库集)</h3><p>FCL 是 .NET Framework 的一部分，它指的是 Framework Class Library（框架类库），也称为 Base Class Library（基础类库）。FCL 是 .NET Framework 的核心组件之一，提供了一组通用的类和类型，用于开发各种类型的应用程序。</p>
<h3 id="特点和功能："><a href="#特点和功能：" class="headerlink" title="特点和功能："></a>特点和功能：</h3><ol>
<li><p><strong>提供丰富的功能：</strong> FCL 包含了大量的类和方法，涵盖了各种常见的编程任务，如文件操作、网络通信、图形界面、数据库访问、加密解密、XML 处理等。</p>
</li>
<li><p><strong>提供跨平台的一致性：</strong> FCL 提供了一组跨平台的类和接口，使得开发人员可以编写跨平台的代码，不受操作系统和硬件平台的限制。</p>
</li>
<li><p><strong>支持面向对象编程：</strong> FCL 中的类和类型都是面向对象的，它们遵循了面向对象编程的原则，如封装、继承、多态等。</p>
</li>
<li><p><strong>提供了强大的异常处理机制：</strong> FCL 提供了强大的异常处理机制，使得开发人员可以轻松地捕获和处理异常，确保程序的稳定性和可靠性。</p>
</li>
<li><p><strong>易于使用和扩展：</strong> FCL 中的类和方法都经过了精心设计和测试，具有良好的文档和示例，使得开发人员可以快速上手并进行开发。此外，FCL 还支持扩展和定制，开发人员可以根据自己的需求进行扩展和定制。</p>
</li>
</ol>
<p>总的来说，FCL 是 .NET Framework 的重要组成部分，为开发人员提供了丰富的功能和强大的工具，帮助他们构建高质量、可靠性和安全性的应用程序。</p>
<h3 id="多语言的融合"><a href="#多语言的融合" class="headerlink" title="多语言的融合"></a>多语言的融合</h3><p>.NET 平台是一个多语言的平台，它支持多种编程语言的开发，并且能够实现这些语言之间的融合和互操作。以下是实现多语言融合的一些主要机制：</p>
<ol>
<li><p><strong>通用类型系统（Common Type System，CTS）：</strong> .NET 平台定义了一种通用的类型系统，所有支持的编程语言都必须遵循该类型系统。这意味着不同的语言可以共享相同的数据类型和对象模型，使得它们可以互相调用和交互。</p>
</li>
<li><p><strong>公共语言运行时（Common Language Runtime，CLR）：</strong> CLR 提供了一个统一的运行时环境，负责管理和执行中间语言（IL）代码。不同的语言编译器可以将源代码编译成 IL，然后由 CLR 执行。这样，不同语言编写的程序可以在相同的运行时环境中运行，并且可以互相调用和交互。</p>
</li>
<li><p><strong>互操作性（Interoperability）：</strong> .NET 平台支持不同语言之间的互操作性。例如，C# 可以调用由 Visual Basic .NET 编写的类，反之亦然。这是通过 CLR 提供的一致的类型系统和通用的对象模型来实现的。</p>
</li>
<li><p><strong>跨语言框架和类库：</strong> .NET 平台提供了许多通用的框架和类库，这些框架和类库可以被不同的语言所使用。例如，Windows Presentation Foundation (WPF)、ASP.NET 和 Windows Communication Foundation (WCF) 等框架都可以被多种语言调用和扩展。</p>
</li>
<li><p><strong>公共语言规范（Common Language Specification，CLS）：</strong> CLS 是一组语言和编译器要遵循的规则和约定，以确保语言间的互操作性和互通性。通过遵循 CLS，开发人员可以编写可在任何 CLR 兼容的语言中使用的代码。</p>
</li>
</ol>
<p>总的来说，.NET 平台提供了一种统一的环境和基础设施，使得不同的编程语言可以共享资源、互相调用和交互，从而实现了多语言的融合和互操作。</p>
<h3 id="语言无关性"><a href="#语言无关性" class="headerlink" title="语言无关性"></a>语言无关性</h3><p> .NET 实现语言无关性的核心在于它的中间语言（Intermediate Language，IL）和公共语言运行时（Common Language Runtime，CLR）的设计。</p>
<p><strong>中间语言（IL）：</strong> .NET 编译器将源代码编译成中间语言（IL），也称为 MSIL（Microsoft Intermediate Language）或 CIL（Common Intermediate Language）。IL 是一种与平台无关的中间表示，类似于汇编语言，但比汇编语言更高级。IL 是一种面向堆栈的语言，它包含了一组指令，这些指令可以在任何实现了 CLR 的平台上运行。</p>
<p><strong>公共语言运行时（CLR）：</strong> CLR 是 .NET 平台的核心组件，负责管理和执行中间语言代码。CLR 提供了许多服务，包括即时编译（Just-In-Time Compilation，JIT）、内存管理、异常处理和安全性等。CLR 将 IL 代码转换为特定平台的本地机器代码，并在运行时执行。这意味着同样的 IL 代码可以在不同的操作系统和架构上运行，因为 CLR 负责处理平台特定的细节。</p>
<p><strong>公共语言规范（CLS）：</strong> .NET 平台还定义了公共语言规范（Common Language Specification，CLS），它是一组语言和编译器要遵循的规则和约定，以确保语言间的互操作性和互通性。通过遵循 CLS，开发人员可以编写可在任何 CLR 兼容的语言中使用的代码。</p>
<p>总的来说，通过 IL 和 CLR 的设计，.NET 平台实现了语言无关性，使得不同的编程语言可以共享相同的运行时环境和类库，从而实现了跨语言的互操作性和代码重用。</p>
<h3 id="第一个c-程序"><a href="#第一个c-程序" class="headerlink" title="第一个c#程序"></a>第一个c#程序</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;<span class="comment">//导入系统命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">NotePad</span> <span class="comment">//定义一个命名空间(不要加分号)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//定义一个类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title">HelloWorld</span>&#123;</span><br><span class="line">    <span class="comment">//Main主方法：程序的入口点</span></span><br><span class="line">    <span class="comment">//public公共的 static静态的 void表示该方法无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line">      <span class="comment">//输出信息 Console控制台类 writeLink输出一行</span></span><br><span class="line">      	console.writeLine(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>在 Windows 操作系统上配置 C# 的环境变量通常是通过安装 .NET Framework 或者 .NET Core SDK 来完成的。下面是基本的步骤：</p>
<p><strong>安装 .NET Framework 或者 .NET Core SDK：</strong></p>
<ul>
<li><p><strong>.NET Framework：</strong> 如果你使用的是旧版的 Windows 操作系统（如 Windows 7、Windows 8.1 或者 Windows 10 中的旧版本），你可以通过安装 .NET Framework 来配置 C# 的环境变量。你可以从 Microsoft 官方网站下载并安装适合你操作系统版本的 .NET Framework。</p>
</li>
<li><p><strong>.NET Core SDK：</strong> 如果你使用的是较新版本的 Windows 操作系统，推荐安装 .NET Core SDK，因为它是跨平台的，并且支持最新的 .NET 开发。你可以从 Microsoft 官方网站下载并安装最新版本的 .NET Core SDK。</p>
</li>
</ul>
<p><strong>配置环境变量：</strong></p>
<ul>
<li><strong>设置 PATH 变量：</strong> 安装完成后，系统会自动配置好 .NET 的相关环境变量。如果没有自动配置，你需要手动将 .NET 相关的可执行文件路径添加到系统的 PATH 环境变量中。通常，.NET Framework 的可执行文件位于 <code>C:\Windows\Microsoft.NET\Framework</code> 或 <code>C:\Windows\Microsoft.NET\Framework64</code> 下，而 .NET Core SDK 的可执行文件位于其安装目录下的 <code>bin</code> 文件夹中。</li>
</ul>
<p><strong>验证安装：</strong></p>
<ul>
<li><p>打开命令提示符或者 PowerShell，输入以下命令来验证 C# 环境是否配置成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csc -version</span><br></pre></td></tr></table></figure>

<p>如果显示了 C# 编译器的版本信息，说明环境配置成功。</p>
</li>
</ul>
<p>请注意，这些步骤可能会因你所使用的 .NET 版本和操作系统版本而略有不同，具体步骤可能需要根据你的环境和需求进行调整。建议在安装过程中仔细阅读官方文档并按照说明进行操作。</p>
<h3 id="Macos上配置dotnet"><a href="#Macos上配置dotnet" class="headerlink" title="Macos上配置dotnet"></a>Macos上配置dotnet</h3><p>在 macOS 上使用 Visual Studio Code 进行 .NET 开发非常方便。以下是一些基本步骤：</p>
<p><strong>安装 .NET Core SDK</strong></p>
<p>首先，你需要安装 .NET Core SDK。你可以从 <a target="_blank" rel="noopener" href="https://dotnet.microsoft.com/download">.NET 官方网站</a> 下载最新版本的 .NET Core SDK，并按照安装说明进行安装。</p>
<p><strong>安装 Visual Studio Code</strong></p>
<p>如果你还没有安装 Visual Studio Code，可以从 <a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code 官方网站</a> 下载最新版本，并按照安装说明进行安装。</p>
<p><strong>安装 C# 扩展</strong></p>
<p>打开 Visual Studio Code，点击左侧的扩展图标（或者按下 <code>Ctrl+Shift+X</code>），搜索并安装 C# 扩展。这个扩展提供了丰富的功能，包括代码补全、调试等。</p>
<p><strong>创建 .NET 项目</strong></p>
<p>在终端中，使用 <code>dotnet new</code> 命令创建一个新的 .NET 项目。例如，要创建一个新的控制台应用程序项目，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet new console -n MyConsoleApp</span><br></pre></td></tr></table></figure>

<p>这会在当前目录下创建一个名为 <code>MyConsoleApp</code> 的新的控制台应用程序项目。</p>
<p><strong>打开项目</strong></p>
<p>在 Visual Studio Code 中，选择 <code>文件 -&gt; 打开文件夹</code>，然后选择你刚刚创建的项目文件夹（例如 <code>MyConsoleApp</code> 文件夹），点击 <code>打开</code>。</p>
<p>** 编写代码**</p>
<p>在 Visual Studio Code 中编辑 <code>Program.cs</code> 文件（或者其他你想编辑的文件），编写 C# 代码。</p>
<p><strong>运行项目</strong></p>
<p>在终端中，导航到项目文件夹（例如 <code>MyConsoleApp</code> 文件夹），然后运行以下命令来构建和运行项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet run</span><br></pre></td></tr></table></figure>

<p>这会编译并执行你的项目。你也可以使用 Visual Studio Code 提供的调试功能来调试你的代码。</p>
<p>通过这些步骤，你就可以在 macOS 上使用 Visual Studio Code 进行 .NET 开发了。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在 C# 中，有三种主要的注释形式：单行注释、多行注释和文档注释。</p>
<p><strong>单行注释</strong></p>
<p>单行注释以双斜杠 <code>//</code> 开头，用于在代码中添加单行注释。单行注释会从 <code>//</code> 开始一直到行尾。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个单行注释</span></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>; <span class="comment">// 这是另一个单行注释</span></span><br></pre></td></tr></table></figure>

<p><strong>多行注释</strong></p>
<p>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结束，用于在代码中添加多行注释。</p>
<p>示例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个多行注释</span></span><br><span class="line"><span class="comment">可以跨越多行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>; <span class="comment">/* 这是一个带有单行注释的多行注释 */</span></span><br></pre></td></tr></table></figure>

<p><strong>文档注释</strong></p>
<p>文档注释以 <code>///</code> 开始，用于为代码中的类型、成员或参数添加注释。文档注释通常用于生成代码文档，可以使用工具如 Visual Studio 的 IntelliSense 来查看。</p>
<p>示例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这是一个类的说明文档注释</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这是一个方法的说明文档注释</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>参数 x 的说明<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;y&quot;&gt;</span>参数 y 的说明<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回值的说明<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档注释以 <code>&lt;summary&gt;</code> 标签开始，用于描述类型、成员或参数的摘要信息。其他常用的标签包括 <code>&lt;param&gt;</code>（描述方法参数）、<code>&lt;returns&gt;</code>（描述返回值）等。</p>
<p><strong>折叠</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">region</span> 折叠</span></span><br><span class="line"><span class="meta"># <span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>

<h3 id="main方法的四种写法"><a href="#main方法的四种写法" class="headerlink" title="main方法的四种写法"></a>main方法的四种写法</h3><p>在 C# 中，<code>Main</code> 方法是程序的入口点，是程序开始执行的地方。通常情况下，<code>Main</code> 方法有四种不同的写法：</p>
<p><strong>最基本的写法</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带参数的写法</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>Main</code> 方法返回 <code>int</code> 类型的写法（用于表示程序的执行状态）</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示程序正常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带参数并返回 <code>int</code> 类型的写法</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 表示程序正常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些写法都是合法的 <code>Main</code> 方法的写法，具体选择哪种写法取决于你的需求和习惯。</p>
<h3 id="项目下的文件含义"><a href="#项目下的文件含义" class="headerlink" title="项目下的文件含义"></a>项目下的文件含义</h3><p><strong>.sln</strong></p>
<p>解决方案，一个解决方案里可以包含多个项目，双击可以同时打开多项目</p>
<p><strong>.csproj</strong></p>
<p>c#项目的启动文件，双击之后可以打开此项目</p>
<p><strong>App.config</strong></p>
<p>配置文件，后面会讲到</p>
<p><strong>bin目录</strong></p>
<p>用来保存项目生成后的程序集，它有debug和release版本，下面有exe文件(项目的可执行文件)</p>
<p><strong>obj目录</strong></p>
<p>用来保存每个模块的编译结果，在.net中，编译是分模块进行的，编译整个完成后会合并成一个.dll或exe文件，保存到bin目录下</p>
<p>**.dll **</p>
<p>项目的类库集</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="两种数据类型"><a href="#两种数据类型" class="headerlink" title="两种数据类型"></a>两种数据类型</h3><ul>
<li>基本数据类型(值类型数据):<ul>
<li>int uint float double char long byte bool Datetime</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>class null</li>
<li>:string是一种特殊引用、类、接口、集合、泛数据类型型等</li>
</ul>
</li>
</ul>
<h3 id="常用的基本数据类型"><a href="#常用的基本数据类型" class="headerlink" title="常用的基本数据类型"></a>常用的基本数据类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔值</td>
<td>True 或 False</td>
<td>False</td>
</tr>
<tr>
<td>byte</td>
<td>8 位无符号整数</td>
<td>0 到 255</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>16 位 Unicode 字符</td>
<td>U+0000 到 U+ffff</td>
<td>‘\0’</td>
</tr>
<tr>
<td>decimal</td>
<td>128 位精确的十进制值，28-29 有效位数</td>
<td>(-7.9 x 10<sup>28</sup> 到 7.9 x 10<sup>28</sup>) &#x2F; 10<sup>0 到 28</sup></td>
<td>0.0M</td>
</tr>
<tr>
<td>double</td>
<td>64 位双精度浮点型</td>
<td>(+&#x2F;-)5.0 x 10<sup>-324</sup> 到 (+&#x2F;-)1.7 x 10<sup>308</sup></td>
<td>0.0D</td>
</tr>
<tr>
<td>float</td>
<td>32 位单精度浮点型</td>
<td>-3.4 x 10<sup>38</sup> 到 + 3.4 x 10<sup>38</sup></td>
<td>0.0F</td>
</tr>
<tr>
<td>int</td>
<td>32 位有符号整数类型</td>
<td>-2,147,483,648 到 2,147,483,647</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64 位有符号整数类型</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
<td>0L</td>
</tr>
<tr>
<td>sbyte</td>
<td>8 位有符号整数类型</td>
<td>-128 到 127</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16 位有符号整数类型</td>
<td>-32,768 到 32,767</td>
<td>0</td>
</tr>
<tr>
<td>uint</td>
<td>32 位无符号整数类型</td>
<td>0 到 4,294,967,295</td>
<td>0</td>
</tr>
<tr>
<td>ulong</td>
<td>64 位无符号整数类型</td>
<td>0 到 18,446,744,073,709,551,615</td>
<td>0</td>
</tr>
<tr>
<td>ushort</td>
<td>16 位无符号整数类型</td>
<td>0 到 65,535</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="Datetime"><a href="#Datetime" class="headerlink" title="Datetime"></a>Datetime</h3><p><code>DateTime</code> 是 C# 中表示日期和时间的数据类型之一。它是一个结构体（struct），位于 <code>System</code> 命名空间中。<code>DateTime</code> 结构体用于表示从公元 1 年 1 月 1 日到 9999 年 12 月 31 日之间的日期和时间。</p>
<p>特点：</p>
<ul>
<li><strong>不可变性</strong>：<code>DateTime</code> 结构体是不可变的，一旦创建了一个 <code>DateTime</code> 对象，就不能修改它的值。</li>
<li><strong>精度</strong>：<code>DateTime</code> 提供了秒的精度，可以表示从 0:00:00 到 23:59:59 之间的时间。</li>
<li><strong>范围</strong>：<code>DateTime</code> 可以表示的日期范围是从公元 1 年 1 月 1 日到 9999 年 12 月 31 日。</li>
<li><strong>时区</strong>：<code>DateTime</code> 本身不包含时区信息，但可以通过 <code>DateTimeKind</code> 枚举来指定日期时间是本地时间、协调世界时 (UTC) 还是未指定的本地时间。</li>
</ul>
<p>常用属性和方法：</p>
<ul>
<li><strong>Now</strong>: 获取当前的日期和时间。</li>
<li><strong>Today</strong>: 获取当前日期的日期部分，时间部分为 00:00:00。</li>
<li><strong>UtcNow</strong>: 获取当前的 UTC 时间。</li>
<li><strong>Parse(string s)</strong>: 将表示日期和时间的字符串转换为 <code>DateTime</code> 对象。</li>
<li><strong>ToString()</strong>: 将 <code>DateTime</code> 对象转换为字符串表示形式。</li>
<li><strong>AddXXX()</strong>: 添加一段时间间隔，例如 <code>AddDays()</code>、<code>AddHours()</code>、<code>AddMinutes()</code> 等。</li>
<li><strong>Subtract(DateTime value)</strong>: 计算两个日期时间之间的时间间隔。</li>
</ul>
<p>示例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DateTime now = DateTime.Now;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Current date and time: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">        DateTime tomorrow = now.AddDays(<span class="number">1</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Tomorrow: &quot;</span> + tomorrow);</span><br><span class="line"></span><br><span class="line">        DateTime birthday = <span class="keyword">new</span> DateTime(<span class="number">1990</span>, <span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Birthday: &quot;</span> + birthday);</span><br><span class="line"></span><br><span class="line">        TimeSpan age = now - birthday;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Age: &quot;</span> + age.Days / <span class="number">365</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们演示了如何创建 <code>DateTime</code> 对象、获取当前日期和时间、进行日期时间的计算等操作。<code>DateTime</code> 类型在 C# 中是非常常用的，用于处理各种与日期时间相关的任务。</p>
<h3 id="隐式类型转换-自动类型转换"><a href="#隐式类型转换-自动类型转换" class="headerlink" title="隐式类型转换&#x2F;自动类型转换"></a>隐式类型转换&#x2F;自动类型转换</h3><p>定义</p>
<p>同一类型的数据(是指都为数值类型),将小范围数据赋值给大范围的目标类型时，将发生自动类型转换</p>
<p>主要应用于数值类型的数据之间的转换，从低精度自动转换到高精度<br>小范围到大范围:低精度到高精度</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>--<span class="built_in">short</span>--<span class="built_in">int</span>--<span class="built_in">long</span>--<span class="built_in">float</span>--<span class="built_in">double</span></span><br></pre></td></tr></table></figure>

<p>特点</p>
<ul>
<li><p>bool类型不能转换成其他的数值类型，数值类型也不能转换为bool类型</p>
</li>
<li><p>byte short char int 四种类型存储的实际上都是整数，int类型的数据可以赋值给byte、short，但是不能超过其数据类型的范围<br>int类型 short byte可以赋给char类型的</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> c1=(<span class="built_in">char</span>)<span class="number">100</span>; <span class="comment">//强制类型转换</span></span><br></pre></td></tr></table></figure>

<ul>
<li>byte short int char之间存在如下隐式转换关系</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>--<span class="built_in">short</span></span><br><span class="line"><span class="built_in">byte</span>--<span class="built_in">int</span></span><br><span class="line"><span class="built_in">short</span>--<span class="built_in">int</span></span><br><span class="line"><span class="built_in">char</span>--<span class="built_in">int</span></span><br></pre></td></tr></table></figure>

<ul>
<li>byte short char三种类型的数据参与运算时，先一律转换为int类型再进行运算的</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">short</span> s1=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">short</span> s2=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">short</span> s3=s1+s2;<span class="comment">//报错</span></span><br><span class="line">s4 = s3 + <span class="string">&#x27;A&#x27;</span>;<span class="comment">//正确，把A转换为ASCII码，再参与运算</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多种基本数据参与的表达式运算中，运算结果会自动的向较大的类型进行转换，个别时候会有精度的丢失,但不影响运算</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> n1 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">float</span> f1 = <span class="number">200.5f</span>;</span><br><span class="line"><span class="built_in">short</span> sss = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">float</span> ddd = n1 + f1 + sss;</span><br></pre></td></tr></table></figure>

<h3 id="显式类型转换-强制类型转换"><a href="#显式类型转换-强制类型转换" class="headerlink" title="显式类型转换&#x2F;强制类型转换"></a>显式类型转换&#x2F;强制类型转换</h3><p>定义</p>
<p>主要应用于数值类型的数据之间的转换，从高精度自动转换到低精度</p>
<blockquote>
<p>double–&gt;float–&gt;long–&gt;int–&gt;short–&gt;byte</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double d=10.5;</span><br><span class="line">int num=dd;//报错</span><br><span class="line">int num=(int)dd;//强制，精度丢失</span><br></pre></td></tr></table></figure>

<h3 id="值类型和引用类型的转换"><a href="#值类型和引用类型的转换" class="headerlink" title="值类型和引用类型的转换"></a>值类型和引用类型的转换</h3><p>值类型转换为引用类型</p>
<ul>
<li>ToString()</li>
</ul>
<p>引用类型转换值类型</p>
<ul>
<li>引用类型转换值类型:XXX.Parse()方法</li>
<li>引用类型转换值类型:Convert.ToXXX()</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Convert.ToInt16() <span class="comment">//short类型</span></span><br><span class="line">Convert.ToInt32()<span class="comment">//int类型</span></span><br><span class="line">Convert.ToInt64() <span class="comment">//long类型</span></span><br><span class="line">Convert.ToSingle() <span class="comment">//float类型</span></span><br><span class="line">Convert.ToDouble() <span class="comment">//double类型</span></span><br><span class="line">Convert.ToChar() <span class="comment">//char类型</span></span><br><span class="line">Convert.ToByte() <span class="comment">//byte类型</span></span><br></pre></td></tr></table></figure>

<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>值类型和引用类型之间的转换</p>
<ul>
<li><p>装箱 将值类型转换为引用类型的过程</p>
</li>
<li><p>拆箱 将引用类型转换为值类型的过程</p>
</li>
</ul>
<blockquote>
<p>object类是C#中所有类的根类或基类或父类</p>
</blockquote>
<p>作用</p>
<p>装箱和拆箱的功能，可通过值类型的任何值与object类型的值相互转换，将值类型与引用和类型衔接起来</p>
<p>注意事项</p>
<blockquote>
<p>因为装箱时是什么样的数据类型，拆箱时就必须拆成什么样的类型</p>
</blockquote>
<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>变量就是内存中一块存储区域的名称，叫变量</p>
<h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><p>建议使用<strong>驼峰命名法</strong>，第一个单词首字母小写，其余单词首字母大写</p>
<ul>
<li><p>在C#中，定义变量要见名知意，不要随意使用a b c d 例num&#x3D;100</p>
</li>
<li><p>变量名一般不建议使用中文命名</p>
</li>
<li><p>不能使用一些关键字来作为变量名<br>关键字:在C#中赋予特定含义的单词</p>
</li>
<li><p>特点：全部为小写的，常用的代码编译器，关键字都有特殊颜色标记，非常直观的，不需要记忆</p>
<ul>
<li>变量名不能以数字开头，但是可以用下划线开头</li>
<li>变量名中不能包含一些特殊字符，比如制表符\t  换行符\n  空格 、 * &amp; ？等</li>
<li>在C#中大小写敏感的，区分大小写的</li>
</ul>
</li>
<li><p>注意点:</p>
<ul>
<li><p>同一变量不允许重复定义(同一个作用域{}),一对{}代表一个作用域</p>
</li>
<li><p>变量的定义，先定义后赋值再使用</p>
</li>
</ul>
</li>
</ul>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>先声明后赋值</p>
<p>数据类型  变量名;    &#x2F;&#x2F;变量的声明<br>变量名&#x3D;值;   &#x2F;&#x2F;变量的初始化，给变量赋值，从右向左赋值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num;  <span class="comment">//声明变量</span></span><br><span class="line">num =<span class="number">100</span>;  <span class="comment">//把100赋给num</span></span><br></pre></td></tr></table></figure>

<p>在声明的同时直接赋值</p>
<p>数据类型  变量名&#x3D;值;</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h3 id="定义变量的注意事项"><a href="#定义变量的注意事项" class="headerlink" title="定义变量的注意事项"></a>定义变量的注意事项</h3><ul>
<li><p>未经声明的变量不能使用，否则会报错</p>
</li>
<li><p>一条语句可以同时声明多个变量，但是必须是同一个类型的变量</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="built_in">int</span> b=<span class="number">2</span>,c=<span class="number">3.2f</span>;<span class="comment">//错误的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>未经初始化的变量不能使用</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a;</span><br><span class="line">cw(a); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以对变量的值进行存取操作，但是其结果必须与原类型相匹配</li>
<li>在同一个作用域(一对花括号就是一个作用域)，变量的名称是不可以重复的</li>
<li>如何从键盘接收数据以及进行数据类型的转换:</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine（“请输入一个数:”）；</span><br><span class="line"><span class="built_in">string</span> num=Console.ReadLine();<span class="comment">//接收一行</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如何转换为数值类型:</p>
<ul>
<li>int类型:int.Parse();</li>
<li>float类型:float.Parse();</li>
<li>double类型:double.Parse();short.Parse(); long.Parse();  decimal.Parse();char.Parse():注意输入的字符串必须是单个的字符，否则报错</li>
</ul>
</li>
<li><p>char类型:char其实是一个16位无符号的整数，这个值对应字符的编码，.net中采用的国际统一的标准的unicode双字节编码格式,char型可以存储数字、英文、中文字符</p>
<ul>
<li>字符可以采用单个中文的形式<br>char c&#x3D;’中’</li>
<li>也可以是16进制的表示形式<br>char c&#x3D;’\u4e2d’;</li>
<li>可以直接字符对应的ASCII码赋给char型的变量,char类型的数据可以int类型之间进行相互转换  (int)a    (char)100<br>ASCII码:美国标准信息交换码</li>
<li>char型 可以参与运算，此时会将字符转换ASCII码再去运算</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> c=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">cw(c+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>其他的数据类型<ul>
<li>sbyte:范围-128–+127之间</li>
<li>byte:范围0–255之间</li>
<li>uint ushort ulong:无符号整型  正数</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据类型后面加？，变量可以为空</p>
</blockquote>
<h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><p>在 C# 中，<code>var</code> 关键字用于声明隐式类型变量，即编译器根据初始化语句的类型自动推断变量的类型。使用 <code>var</code> 关键字可以简化代码，减少重复，并提高代码的可读性。</p>
<p>用法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variableName = <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>variableName</code> 是变量名，<code>value</code> 是变量的初始化值。编译器会根据 <code>value</code> 的类型推断出 <code>variableName</code> 的类型。</p>
<p>示例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 推断为 string 类型</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">10</span>; <span class="comment">// 推断为 int 类型</span></span><br><span class="line"><span class="keyword">var</span> pi = <span class="number">3.14</span>; <span class="comment">// 推断为 double 类型</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// 推断为 int[] 类型</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，编译器会根据初始化语句的类型自动推断变量的类型，并将其替换为对应的类型。使用 <code>var</code> 关键字时，变量的类型必须在初始化时被确定，因此无法使用 <code>var</code> 声明未初始化的变量。</p>
<p>需要注意的是，<code>var</code> 关键字声明的变量是静态类型，即一旦推断出变量的类型，它就不能更改。因此，<code>var</code> 关键字不能用于声明匿名类型（anonymous types）的变量，因为匿名类型的类型在编译时无法确定。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在程序运行过程中，其值一直保持不变，可以定义成常量</p>
<p>示例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 数据类型  <span class="comment">//常量名=常量值;</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> PI=<span class="number">3.14</span>;  <span class="comment">//常量的定义的初始化</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 一般情况下，常量名建议使用纯大写的</p>
</blockquote>
<blockquote>
<p>在程序运行中，不可以修改常量值</p>
</blockquote>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a>连接符</h3><p><strong>加号运算符（+）</strong>：加号运算符是最常见的连接字符串的方式。它可以将两个字符串连接起来，并返回一个新的字符串。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> result = str1 + <span class="string">&quot; &quot;</span> + str2; <span class="comment">// 连接两个字符串并赋值给result变量</span></span><br></pre></td></tr></table></figure>

<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符是在字符串中使用的特殊字符序列，用于表示一些特殊的字符或控制字符。在C#中，常见的转义字符包括：</p>
<ol>
<li><strong>\n</strong>：换行符，表示在字符串中换行。</li>
<li><strong>\r</strong>：回车符，表示将光标移到当前行的开头。</li>
<li><strong>\t</strong>：制表符，表示在字符串中插入一个制表符。</li>
<li><strong>\</strong>：反斜杠，表示在字符串中插入一个反斜杠。</li>
<li><strong>&#39;</strong>：单引号，表示在字符串中插入一个单引号。</li>
<li><strong>&quot;</strong>：双引号，表示在字符串中插入一个双引号。</li>
</ol>
<p>下面是一些示例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;Hello\nWorld&quot;</span>; <span class="comment">// 换行</span></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;C:\\Users\\&quot;</span>; <span class="comment">// 插入反斜杠</span></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;She said: \&quot;Hello!\&quot;&quot;</span>; <span class="comment">// 插入双引号</span></span><br><span class="line"><span class="built_in">string</span> str4 = <span class="string">&quot;It\&#x27;s raining&quot;</span>; <span class="comment">// 插入单引号</span></span><br></pre></td></tr></table></figure>

<p>在字符串中，如果想要表示这些特殊字符，就需要使用转义字符。通过转义字符，可以使字符串中包含一些无法直接输入的字符，从而实现更灵活的字符串处理。</p>
<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;,name,id,sex&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span><span class="subst">&#123;id&#125;</span><span class="subst">&#123;sex&#125;</span>);</span></span><br></pre></td></tr></table></figure>

<h3 id="Console类"><a href="#Console类" class="headerlink" title="Console类"></a>Console类</h3><p><strong>Console.ReadKey();</strong></p>
<p>是一个 C# 中的方法，它用于从控制台读取用户输入的单个字符，并返回表示该字符的 ConsoleKeyInfo 对象。Console.ReadKey() 方法通常用于等待用户按下一个键，然后继续执行程序的后续逻辑。<br>该方法在程序执行时会阻塞（即暂停执行），直到用户按下一个键为止。一旦用户按下了一个键，程序将会继续执行。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>

<p>Console.Clear();</p>
<p>当用户按下任意键后，调用 <code>Console.Clear()</code> 方法将清空控制台窗口上的所有文本内容，然后输出两行新的文本。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Clear(); <span class="comment">// 清屏</span></span><br></pre></td></tr></table></figure>

<p>Console.WriteLine();</p>
<p> C# 中用于在控制台窗口中输出文本的方法。它接受一个字符串作为参数，并在控制台中显示该字符串，然后自动换行。如果不传递任何参数，它将只输出一个空行。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine();</span><br></pre></td></tr></table></figure>

<p>Console.ReadLine();</p>
<p>C# 中用于从控制台读取用户输入的方法。它会在程序执行时暂停，并等待用户在控制台中输入文本，直到用户按下回车键为止。然后，该方法将返回用户输入的文本作为一个字符串。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.ReadLine() </span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>优先级：小括号&gt;一元运算符&gt;二元元算符</p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++ <span class="comment">//自身加一</span></span><br><span class="line">-- <span class="comment">//自身减一</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果++–作为一条单独的语句，不管++–在前在后，都是表示自身加一或自身减一</li>
<li>如果++–参与操作时（输出，赋值，运算）的时候，如果++–在前时，表示先自身加一或减一，再参与操作</li>
<li>如果++–参与操作时（输出，赋值，运算）的时候，如果++–在后时，表示先参与操作，再自身加一或减一</li>
</ul>
<h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="comment">//加</span></span><br><span class="line">- <span class="comment">//减</span></span><br><span class="line">* <span class="comment">//乘</span></span><br><span class="line">/ <span class="comment">//除</span></span><br><span class="line">% <span class="comment">//取余</span></span><br></pre></td></tr></table></figure>

<p>二元运算符的应用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num1 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span> num2 = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">double</span> num3 = <span class="number">3.0</span>;</span><br><span class="line">Console.WriteLine(num1 + num2);</span><br></pre></td></tr></table></figure>

<p>保留两位小数输出</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WiteLine(<span class="string">&quot;&#123;0:f2&#125;&quot;</span>,num1/num2)</span><br><span class="line">Console.WiteLine(<span class="string">&quot;&#123;0:0.00&#125;&quot;</span>,num1/num2)</span><br></pre></td></tr></table></figure>

<p>使用命令行参数为main方法传递值：调试&gt;项目属性&gt;</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">== 等于</span><br><span class="line">=！ 不等于</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt; 小于</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">&lt;= 小于等于</span><br></pre></td></tr></table></figure>

<p>运算结果都为bool型，结果为true或者false。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>一般情况下，用来连接bool类型的表达式或值</p>
<p>表达式：就是把运算符把常量或变量连接起来的式子</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp; 逻辑与 <span class="comment">//并且的关系 有false结果为false</span></span><br><span class="line">| 逻辑或 <span class="comment">//或者的关系 有true结果为true</span></span><br><span class="line">! 逻辑非 <span class="comment">//取反的操作 </span></span><br><span class="line">^ 逻辑异或 <span class="comment">//相同为false 不同为true 按位异或</span></span><br><span class="line"><span class="comment">/*0代表false 1代表true*/</span></span><br></pre></td></tr></table></figure>

<h3 id="短路操作"><a href="#短路操作" class="headerlink" title="短路操作"></a>短路操作</h3><p>&amp;&amp;:短路与 </p>
<p>||:短路或</p>
<ul>
<li><p>&amp;&amp;与&amp;的区别</p>
<ul>
<li>最终结果一样</li>
<li>.&amp;&amp;具有短路效果，如果左边表达式是false,则右边不执行<br>&amp;无论左边是false还是true,右边表达式都会执行</li>
</ul>
</li>
<li><p>||和|的区别:</p>
<ul>
<li>最终结果一样</li>
<li>||具有短路效果，如果左边表达式是true时，右边不执行<br>|无论左边是true或false，右边都会执行</li>
</ul>
</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>复合赋值运算符:扩展运算符</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+=   -+   /=   *=   %=</span><br><span class="line">num=<span class="number">5</span>;</span><br><span class="line">num+=<span class="number">10</span>;等价于num=num+<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>三目运算符(条件运算符)<br>示例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(关系表达式)?表达式<span class="number">1</span>:表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>执行原理:</p>
<ul>
<li>如果关系表达式的值true时，运算后的结果就是表达式1；</li>
<li>如果关系表达式的值为false时，运算后的结果就是表达式2;</li>
</ul>
<p>例如:求两个数的较大数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x=<span class="number">3</span>,y=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">int</span> z=(x&gt;y)?x:y;</span><br></pre></td></tr></table></figure>

<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>一元运算符&gt;二元运算符&gt;关系运算符&gt;逻辑运算符&gt;赋值运算符</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">()</span><br><span class="line">++ -- !</span><br><span class="line">* / %</span><br><span class="line">+ -</span><br><span class="line">&gt;= &lt;= &gt; &lt;</span><br><span class="line">== !=</span><br><span class="line">| ||</span><br><span class="line">= += -= *= /= %=</span><br></pre></td></tr></table></figure>

<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>程序中最简单的最基本的流程控制，没有特定的语法结构，按照代码的先后顺序依次执行，程序中的大多数的代码都是这样执行的。</p>
<h3 id="判断结构"><a href="#判断结构" class="headerlink" title="判断结构"></a>判断结构</h3><p>根据不同的条件执行不同的语句</p>
<p>If单分支结构</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">  语句体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果true，就执行语句体</span></span><br><span class="line"><span class="comment">//如果false，就不执行语句体</span></span><br></pre></td></tr></table></figure>

<p>判断成绩是否合格</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> score</span><br><span class="line">Console.WirteLine(<span class="string">&quot;请输入一个成绩：（0-100）&quot;</span>);</span><br><span class="line">score = convert.Toint32(Console.ReadLine());</span><br><span class="line"><span class="comment">//进行条件判断</span></span><br><span class="line"><span class="keyword">if</span>(score &gt;=<span class="number">60</span>)&#123;</span><br><span class="line">  Console.WiteLine(<span class="string">&quot;恭喜成绩合格&quot;</span>)；</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;抱歉成绩不合格&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>if…else双分支结构</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">  语句体<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  语句体<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">执行流程:</span><br><span class="line">首先判断条件表达式看其结果是<span class="literal">true</span>还是<span class="literal">false</span></span><br><span class="line">如果是<span class="literal">true</span>就执行语句体<span class="number">1</span></span><br><span class="line">如果是<span class="literal">false</span>就执行语句体<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>If..else if..else多分支结构</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">  语句<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">  语句<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">  语句<span class="number">3</span>&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">执行流程:</span><br><span class="line">首先判断条件表达式<span class="number">1</span>,看其结果是<span class="literal">true</span>还是<span class="literal">false</span></span><br><span class="line">如果是<span class="literal">true</span>,就执行语句体<span class="number">1</span></span><br><span class="line">如果是<span class="literal">false</span>，就继续判断条件表达式<span class="number">2</span>,看其结果是<span class="literal">true</span>还是<span class="literal">false</span></span><br><span class="line">如果是<span class="literal">true</span>,就执行语句体<span class="number">2</span></span><br><span class="line">如果是如果是<span class="literal">false</span>，就继续判断条件表达式<span class="number">3</span>,看其结果是<span class="literal">true</span>还是<span class="literal">false</span></span><br><span class="line">......</span><br><span class="line">如果以上所有条件表达式均不成立时，就执行<span class="keyword">else</span>后的语句体n</span><br><span class="line"></span><br><span class="line">注意:在众多分支中，只执行一个分支</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>if多分支总结</p>
<ul>
<li>else分支可有可无，不满足条件时的情况处理</li>
<li>if后面可以有多个else-if，但是不能单独出现和if一起使用</li>
<li>每个分支都可做条件判断，最终有且只能执行一个分支</li>
<li>多分支结构适合判断某个范围时或精确的判断也可以使用</li>
</ul>
<p><strong>switch-case</strong></p>
<p>多重条件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(条件变量)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ......</span><br><span class="line">     <span class="literal">default</span>:</span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程:</p>
<ul>
<li>当条件变量和常量1匹配时，就执行语句体1,然后break退出条件匹配</li>
<li>当条件变量和常量1不匹配时，继续和常量2相匹配，如果匹配则执行语句体2,break退出</li>
<li>当条件变量和常量2不匹配时，继续和常量3相匹配,…..</li>
<li>如果条件变量和case后面每个条件都不匹配，则执行default语句</li>
</ul>
<blockquote>
<p>注意：case后面的常量类型只能是byte或short或int或char或enum或String类型</p>
</blockquote>
<p>区分两个多重条件匹配:</p>
<ul>
<li>如果精确的匹配时，量不多时，二者均可使用</li>
<li>如果要判断某个范围时，那要用if-else if</li>
</ul>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>循环定义:循环重复地做某件事情，在某个时刻满足某个条件时，就退出循环</p>
<p>while循环、do-while循环、for循环、foreach</p>
<p>循环的三要素:</p>
<ul>
<li>循环变量初始化</li>
<li>循环条件表达式</li>
<li>循环的更新：改变循环变量的值</li>
</ul>
<p><strong>while</strong></p>
<p>也叫前置循环或当型循环</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)</span><br><span class="line">&#123;</span><br><span class="line"> 循环操作的内容;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当满足某一个条件时才去执行循环操作的内容，其中循环条件是一个布尔类型的值(true&#x2F;false)</p>
<p>执行流程:</p>
<ul>
<li><p>计算条件表达式的值</p>
</li>
<li><p>如果值为true时，就执行循环体语句，语句块执行完成后，再次判断条件表达式的值，如果为true,就继续执行循环体语句，如此往复循环，直到某一个时刻，条件表达式的值为false时，退出while循环</p>
</li>
</ul>
<p><strong>do-while</strong></p>
<p>后置循环也叫直到型循环</p>
<p>无论是否满足循环的条件，都会至少执行一次循环体的内容。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure>

<p>执行流程:</p>
<ul>
<li>先执行循环体语句一次</li>
<li>再计算条件表达式的值，如果true，再次执行循环体语句，如此往复循环，直到某个时刻条件表达式的值为false时退出循环</li>
</ul>
<blockquote>
<p>注意：无论条件表达式的式值为真为假，循环体语句至少执行一次</p>
</blockquote>
<p><strong>for</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line">  (语句四)循环体语句;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式1:用来初始化循环变量 int i=1；</span></span><br><span class="line"><span class="comment">//表达式2:用来进行条件判断的，他是条件表达式</span></span><br><span class="line"><span class="comment">//表达式3:循环变量的更新，改变循环量大值</span></span><br></pre></td></tr></table></figure>

<p>执行流程</p>
<ul>
<li>计算表达式1的值</li>
<li>计算表达式2的值，如果是true，执行循环体语句，否则推出</li>
<li>执行循环体语句</li>
<li>执行表达式3改变循环变量的值</li>
<li>计算表达式2（条件表达式）如果为true，执行循环语句，如果假则推出</li>
</ul>
<p>如此往复</p>
<p>执行过程1&gt;2&gt;4&gt;3&gt;2&gt;4&gt;3&gt;2&gt;4</p>
<blockquote>
<p> 用的几率最高，表达式写在一起不容易遗忘</p>
</blockquote>
<p>注意事项：for循环的特殊用法</p>
<ul>
<li>循环变量初始化的位置可以为空。</li>
<li>表达式3的位置可以为空，可以写在循环体内</li>
<li>表达式123均为空（死循环）</li>
<li>表达式1，3内容多样化：1，3可以使用逗号表达式，隔开多个表达式，从左向右计算</li>
</ul>
<p>#for循环和while的区别</p>
<p>for循环做定值循环时比较方便</p>
<ul>
<li>不用定定义多个变量，一个变量可以多次引用</li>
</ul>
<p>#循环的嵌套</p>
<p>外层循环打印行数，内层循环负责每行打印的具体内容</p>
<p>#打印99乘法表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		Console.Write(<span class="string">&quot;&#123;0&#125;*&#123;1&#125;=&#123;2&#125;\t&quot;</span>, i, j, i * j);</span><br><span class="line">	&#125;</span><br><span class="line">Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>foreach</strong></p>
<p><code>foreach</code> 循环是 C# 中一种用于遍历集合类型（如数组、列表、集合等）的简便方式。它提供了一种更简洁、更直观的方式来遍历集合中的元素，而无需使用索引或迭代器。</p>
<p>其基本语法如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>var item</code>**：定义一个临时变量 <code>item</code>，用于存储集合中的每个元素。</li>
<li>**<code>collection</code>**：要遍历的集合，可以是数组、列表、集合等实现了 <code>IEnumerable</code> 或 <code>IEnumerable&lt;T&gt;</code> 接口的类型。</li>
</ul>
<p>下面是一个简单的示例，演示了如何使用 <code>foreach</code> 循环遍历数组并计算数组元素的总和：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> numbers)</span><br><span class="line">&#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Sum of numbers: &quot;</span> + sum);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>foreach</code> 循环会自动迭代数组 <code>numbers</code> 中的每个元素，并将当前元素赋值给变量 <code>number</code>，然后执行循环体中的代码。这种方式简化了遍历数组的过程，让代码更加简洁和易读</p>
<p><strong>break</strong></p>
<p>用在switch-case语句中，表示中止或中断条件匹配（推出条件匹配），如果用在循环里面，跳出当前所在的循环，常常与条件语句一起来使用。</p>
<p><strong>continue</strong></p>
<p>与break不同，不能用于在循环中，其作用是跳过本次循环，尝试进入下一次循环。</p>
<p><strong>goto</strong></p>
<p>跳出两层循环，但是不推荐使用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> playAgain = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> num1;</span><br><span class="line"><span class="built_in">int</span> num2; </span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">num2 = r.Next(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;第<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>次机会&quot;</span>);</span><br><span class="line">        num1 = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        <span class="keyword">if</span> (num1 == num2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;恭喜你猜中了&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> playagain;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;正确答案是<span class="subst">&#123;num2&#125;</span>&quot;</span>);</span><br><span class="line">    playagain:</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;是否再来一局,输入y/Y,其他键退出&quot;</span>);</span><br><span class="line">    playAgain = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (playAgain == <span class="string">&quot;y&quot;</span> | playAgain == <span class="string">&quot;Y&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>c#中的一种数据类型，是引用数据类型</p>
<p>是用来保存一组数据类型相同的值称为数组</p>
<p>数组是种引用的数据类型</p>
<p>值类型的数据在内存中：存储在栈中的</p>
<p>引用类型的数据在内存中：存储在堆（堆栈中）</p>
<h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><ul>
<li><p>表示一组值的时候，可以使用数组（可以是学过的任意的类型，但是同一个数组中的数据类型必须是相同的）</p>
</li>
<li><p>一组数据的遍历（for或foreach）</p>
</li>
<li><p>组操作&gt;赋值&gt;取值&gt;最大值&gt;最小值&gt;排序&gt;平均值等</p>
</li>
</ul>
<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)数据类型[] 数组名=&#123;值<span class="number">1</span>，值<span class="number">2</span>,值<span class="number">3.</span>.....&#125;;<span class="comment">//声明数组的同时直接初始化</span></span><br><span class="line">这是简化版本:</span><br><span class="line">例如:</span><br><span class="line"><span class="built_in">int</span>[]  arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//在数组存储了5个int类型的数据</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)数据类型[] 数组名=<span class="keyword">new</span> 数据类型[数组的长度]&#123;值<span class="number">1</span>,值<span class="number">2</span>,.....&#125;;</span><br><span class="line">例如:</span><br><span class="line"><span class="built_in">int</span>[] arr=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)数据类型[] 数组名=<span class="keyword">new</span> 数据类型[N];<span class="comment">//定义一个数组</span></span><br><span class="line">例如:</span><br><span class="line"><span class="built_in">int</span>[] arr=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>)数据类型[]  数组名;<span class="comment">//数组的声明</span></span><br><span class="line">数组名=<span class="keyword">new</span> 数据类型[N];</span><br><span class="line">例如:</span><br><span class="line"><span class="built_in">double</span>[] arr;</span><br><span class="line">arr=<span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<h3 id="如何访问数组"><a href="#如何访问数组" class="headerlink" title="如何访问数组"></a>如何访问数组</h3><p>通过下标&#x2F;索引来访问数组中的元素</p>
<p>数组名[索引下标] ;</p>
<p>注意:数组中的第一个元素索引下标为0</p>
<p>第二元素索引下标为1……….</p>
<p>数组的长度:数组名.Length;&#x2F;&#x2F;获得数组的长度</p>
<p>通过索引下标访问数组元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.WriyeLine(arr1[<span class="number">0</span>]); <span class="comment">//第一个元素</span></span><br><span class="line">...</span><br><span class="line">console.WriyeLine(arr1[<span class="number">6</span>]); <span class="comment">//第六个元素</span></span><br><span class="line"><span class="comment">//不存在，会有一个错误（异常）索引超出数组界限</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用循环来输出数组中的元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> =<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  Console.WriteLine(arr1[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用foreach</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的典型应用"><a href="#数组的典型应用" class="headerlink" title="数组的典型应用"></a>数组的典型应用</h3><p><strong>最大值、最小值的求法:</strong></p>
<p>算法:一般情况下，是把数组中的第一个元素默认为最大值或最小值，然后拿着这个默认的值，去和数组中的每一个元素相比较，如果大的就赋给最大值，如果小的就赋给最小值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大值</span></span><br><span class="line"><span class="built_in">int</span> [] num=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span> max=num[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(max&lt;num[i])&#123;</span><br><span class="line">    max = num[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line"><span class="built_in">int</span> [] num=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">int</span> min=num[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(min&lt;num[i])&#123;</span><br><span class="line">    min = num[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线性查找:顺序查找</strong></p>
<p>从头找到尾，找到了，给出在第几个位置，如果找不到要给出相应的提示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//将数组中的元素一个一个与被查找的数相比较</span></span><br><span class="line">  <span class="keyword">if</span> (searchNum == nums[i])</span><br><span class="line">  &#123;</span><br><span class="line">    isExist= <span class="literal">true</span>;<span class="comment">//找到了</span></span><br><span class="line">    index = i;<span class="comment">//记录找到的数的索引下标</span></span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">//找到了退出循环，不再继续找了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>排序:对数组中的元素进行升序或降排序</strong></p>
<ul>
<li>冒泡排序:相邻的两个数之间进行相比较，如果是升序，那么就把较小的交接到前面的位置</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外循环：负责一共进行几轮比较的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;score.Length<span class="number">-1</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//内循环：相邻的两个数之间进行相比较</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; score.Length<span class="number">-1</span>-i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//进行比较：&gt;升序，小的往前交换  &lt;降序</span></span><br><span class="line">      <span class="keyword">if</span> (score[j] &lt; score[j+<span class="number">1</span>])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//完成两个数的交换</span></span><br><span class="line">        <span class="built_in">int</span> temp = score[j];</span><br><span class="line">        score[j] = score[j + <span class="number">1</span>];</span><br><span class="line">        score[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择排序:(升序)</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;score.Length<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//内循环:负责第N个位置的数去和后面的每一个相比较：j的初值是可变的</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> j=i+<span class="number">1</span>;j&lt;score.Length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//比较的是i和j的值</span></span><br><span class="line">    <span class="keyword">if</span> (score[i] &gt; score[j])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = score[i];</span><br><span class="line">        score[i] = score[j];</span><br><span class="line">        score[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反序输出:倒数输出</strong></p>
<p>原理 :第一个位置和最后一个位置交换,第二个位置和倒数第二个位置交换,一直交换到中间位置结束</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>,j=score.Length<span class="number">-1</span>;i&lt;j;i++,j--) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//完成i和j的交换</span></span><br><span class="line">	<span class="built_in">int</span> temp = score[i];</span><br><span class="line">	score[i] = score[j];</span><br><span class="line">	score[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; score.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">	Console.Write(score[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义<span class="number">1</span>:定义一个五行五列的数组:二维数组</span><br><span class="line"><span class="built_in">int</span>[,] arr=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>,<span class="number">5</span>];<span class="comment">//五行，五列  默认初始化0</span></span><br><span class="line">在定义的同时直接初始化</span><br><span class="line">例如:</span><br><span class="line"><span class="built_in">int</span>[,] num=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;<span class="comment">//两行三列的数组</span></span><br><span class="line">取值、赋值:</span><br><span class="line">num[<span class="number">0</span>,<span class="number">0</span>]:第一行第一列的值</span><br><span class="line">num[<span class="number">1</span>,<span class="number">0</span>]:第二行第一列的值</span><br><span class="line">num[<span class="number">1</span>,<span class="number">2</span>]:第二行第三列的值</span><br><span class="line">......</span><br><span class="line"><span class="comment">//GetLength(0):获得二组数组中的第一个维数（行数）</span></span><br><span class="line"><span class="comment">//GetLength(1):获得二组数组中的第二个维数（列数）</span></span><br><span class="line"> Console.WriteLine(arr.Rank);<span class="comment">//1表示一维数组，2表二维数组</span></span><br></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//二维数组的赋值</span><br><span class="line">arr[1, 2] = 1000;</span><br><span class="line">arr.SetValue(2000, 2, 1);//2000表示赋值的值，2第三行 1第二列</span><br><span class="line"></span><br><span class="line">//获得二维数组的值</span><br><span class="line">Console.WriteLine(&quot;第二行第三列的值:&quot; + arr[1,2]);</span><br><span class="line">Console.WriteLine(&quot;第三行第二列的值:&quot;+arr.GetValue(2,1));</span><br></pre></td></tr></table></figure>

<h3 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h3><p>称为锯齿数组，数组的元素可以是另一个数组</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明:</span></span><br><span class="line"><span class="built_in">int</span>[][] arr=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];<span class="comment">//只行指定行数，列数待定</span></span><br><span class="line">arr[<span class="number">0</span>]=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>]; <span class="comment">//第一行</span></span><br><span class="line">arr[<span class="number">1</span>]=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];<span class="comment">//第二行</span></span><br><span class="line">arr[<span class="number">2</span>]=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;;<span class="comment">//直接初始化，第三行</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举（Enumeration）是一种用户定义的数据类型，用于表示一组命名的常数值。在 C# 中，枚举类型允许您定义一个命名的整数常量集合，这些常量称为枚举成员。枚举成员的值可以是整数、浮点数或字符类型。</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol>
<li><strong>简化代码：</strong> 枚举使代码更易于理解和维护，因为它提供了有意义的命名，而不是硬编码的数字或字符串。</li>
<li><strong>类型安全：</strong> 枚举提供了类型安全，因为它只允许使用在枚举中定义的成员。</li>
<li><strong>可读性：</strong> 使用枚举可以提高代码的可读性，因为它使得代码更易于理解。</li>
</ol>
<h3 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h3><p>在 C# 中，枚举通过 <code>enum</code> 关键字定义。以下是一个示例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> DayOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为 <code>DayOfWeek</code> 的枚举，它包含了一周中的每一天。默认情况下，枚举成员的值从 0 开始，依次递增。在这个例子中，<code>Sunday</code> 的值为 0，<code>Monday</code> 的值为 1，依此类推。</p>
<h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>使用枚举时，您可以直接通过枚举的名称来访问其成员。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DayOfWeek today = DayOfWeek.Friday;</span><br><span class="line">Console.WriteLine(today); <span class="comment">// 输出: Friday</span></span><br></pre></td></tr></table></figure>

<p>您还可以将枚举成员的值转换为整数，并将整数值转换为枚举成员：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> dayValue = (<span class="built_in">int</span>)DayOfWeek.Wednesday;</span><br><span class="line">Console.WriteLine(dayValue); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">DayOfWeek nextDay = (DayOfWeek)(dayValue + <span class="number">1</span>);</span><br><span class="line">Console.WriteLine(nextDay); <span class="comment">// 输出: Thursday</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举的底层实现"><a href="#枚举的底层实现" class="headerlink" title="枚举的底层实现"></a>枚举的底层实现</h3><p>在底层，枚举成员的值实际上是整数常量。默认情况下，第一个成员的值为 0，并依次递增。您可以显式地指定枚举成员的值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status</span><br><span class="line">&#123;</span><br><span class="line">    Inactive = <span class="number">0</span>,</span><br><span class="line">    Active = <span class="number">1</span>,</span><br><span class="line">    Pending = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Inactive</code> 的值为 0，<code>Active</code> 的值为 1，<code>Pending</code> 的值为 2。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>枚举是一种强大的工具，用于定义一组命名的常量值。它使得代码更易于理解和维护，提高了代码的可读性和可维护性。枚举还提供了类型安全和更清晰的语义，使得程序员能够更轻松地操作常量值。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>在 C# 中，结构体（Struct）是一种用户自定义的值类型。与类（Class）不同，结构体是一种轻量级的数据结构，通常用于表示具有少量数据成员的简单对象。结构体在内存中的存储方式和类有所不同，它们通常被分配在栈上，而不是堆上，这使得它们在内存管理方面更加高效。</p>
<h3 id="特点和用法"><a href="#特点和用法" class="headerlink" title="特点和用法"></a>特点和用法</h3><ul>
<li>值类型</li>
</ul>
<p>结构体是值类型，因此它们的实例在传递给方法时是按值传递的，而不是按引用传递。这意味着当传递结构体实例时，将会复制整个结构体的内容。</p>
<ul>
<li>轻量级</li>
</ul>
<p>结构体通常用于表示简单的数据结构，比如坐标、颜色、矩形等。由于它们比类更轻量级，所以在某些情况下更适合用于存储小型数据。</p>
<ul>
<li>不支持继承</li>
</ul>
<p>结构体不支持继承，即不能派生出其他结构体或类。它们是最基本的自定义类型。</p>
<ul>
<li>默认构造函数</li>
</ul>
<p>结构体会自动创建一个默认的无参数构造函数，该构造函数会将所有成员变量初始化为其默认值。但也可以手动定义构造函数。</p>
<ul>
<li>可包含字段、属性、方法等</li>
</ul>
<p> 结构体可以包含字段、属性、方法等成员，可以定义其行为和状态。</p>
<ul>
<li>性能优化</li>
</ul>
<p>结构体通常比类更高效，因为它们在栈上分配内存，而不需要额外的垃圾回收操作。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>在 C# 中，类（Class）是一种用户自定义的数据类型，用于表示一组具有相似特征和行为的对象。类是面向对象编程的基本构建块，它可以包含字段、方法、属性、构造函数、事件等成员，以及内部类、枚举等其他类型。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>封装性</strong>：类封装了数据（字段）和行为（方法），对外部隐藏了内部实现细节，只暴露公共的接口。</p>
<p><strong>继承性</strong>：类可以通过继承机制派生出子类，子类可以继承父类的成员并扩展或修改其行为。</p>
<p><strong>多态性</strong>：通过虚方法和抽象类等特性，实现了多态性，使得不同的对象可以以相同的方式被操作。</p>
<h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><p>实例化对象:根据student类型创建了一个stu1变量，他进行了赋值，指向了一个Student类型的对象。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu1=<span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>

<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>变量名访问成员变量</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员   </span><br><span class="line">stu1.name</span><br></pre></td></tr></table></figure>

<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li>pravate 私有的</li>
<li>protected 被保护的</li>
<li>internal （类默认）可以在同一个程序集里被访问</li>
<li>public 公开的（权限最大）</li>
</ul>
<blockquote>
<p>成员变量前面省略修饰符默认为pravate</p>
<p>类前面省略修饰符默认为internal</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在实例化对象时自动调用的方法</p>
<p>定义：成员变量做初始化</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Cellphone（）&#123;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用了构造方法&quot;</span>)</span><br><span class="line">  band = <span class="string">&quot;iphone&quot;</span>;</span><br><span class="line">  color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带参数的构造方法，用来给成员变量做初始化</span></span><br><span class="line"><span class="keyword">public</span> Phone（<span class="built_in">string</span> b）</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>this代表一个对象，在构造方法中，他代表的是正在示例化的这个对象</p>
<p>**构造方法的重载 **</p>
<p>可以是有多个构造方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Card</span> ()</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Card</span> (<span class="params"><span class="built_in">long</span> id,<span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Card</span> (<span class="params"><span class="built_in">long</span> id,<span class="built_in">string</span> name,<span class="built_in">bool</span> sex</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>构造方法的名称必须和类相同</li>
<li>在示例化对象时自动调用的方法</li>
<li>构造方法用于对成员变量进行初始化，不做其他业务处理</li>
<li>构造方法中的this代表一个对象，在构造方法中，他代表的是正在示例化的这个对象。</li>
<li>类中默认会提供一个无参对构造方法，如果自定义了构造方法，则类中不会知道生成无参构造</li>
<li>构造方法的参数可以是变量</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>方法在类中代表一种行为能力，代表对象应该具有的功能，实现代码的复用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符]返回类型 方法名([参数列表])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//方法的主体语法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">method</span> (<span class="params"><span class="built_in">int</span> r</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">double</span> area;</span><br><span class="line">  arra=<span class="number">3.14</span>*r*r;</span><br><span class="line">  <span class="keyword">return</span> area;  <span class="comment">// 获取圆的面积，返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>方法名采用Pascal命名法，要体现方法的作用，一般是动词或动词加名词的形式。</li>
<li>方法的参数可以为空，也可以又一个或多个参数，多个参数之间用逗号取分割</li>
<li>如果方法没有返回值，返回类型声明为viod，如果有返回值，返回类型必须和返回值的类型匹配</li>
<li>访问修饰符省略时，默认为pravate</li>
</ul>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>实例方法要通过对象调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名(参数)</span><br></pre></td></tr></table></figure>

<p>this代表正在调用这个方法的对象</p>
<h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p>在 C# 中，递归调用是指一个方法在执行过程中调用了自身。递归通常用于解决可以被拆解为相同问题的子问题的情况，例如树遍历、阶乘计算、斐波那契数列等。在使用递归时，需要确保在适当的条件下结束递归，以避免无限循环。</p>
<p>下面是一个计算阶乘的递归函数的示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">int</span> factorial = Factorial(n);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Factorial of &#123;0&#125; is &#123;1&#125;&quot;</span>, n, factorial);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Factorial</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="comment">// 递归结束条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> n * Factorial(n - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Factorial()</code> 方法在递归调用中调用了自身。当 <code>n</code> 等于 0 时，递归结束，返回 1，否则返回 <code>n</code> 乘以 <code>Factorial(n - 1)</code>。</p>
<p>递归调用需要小心处理，因为如果没有正确的结束条件，会导致无限递归，消耗大量的内存和 CPU 资源，最终导致程序崩溃。因此，在编写递归函数时，确保定义了正确的递归终止条件是非常重要的。</p>
<h3 id="OOP思想"><a href="#OOP思想" class="headerlink" title="OOP思想"></a>OOP思想</h3><ul>
<li>分析业务逻辑，找到核心对象，并且找出对象的特征和行为</li>
<li>根据分析的情况，定义相关的类，并将特征封装成成员变量</li>
</ul>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><ul>
<li><p>return是方法的出口语句；</p>
</li>
<li><p>返回值的类型必须与return 之后的变量值的类型相同</p>
</li>
</ul>
<h3 id="方法的参数"><a href="#方法的参数" class="headerlink" title="方法的参数"></a>方法的参数</h3><p>作用：接收外部提供的数据，如果方法有参数的，则调用方法时，必须提供和参数个数和类型都匹配的实参，实参传递给形参</p>
<h3 id="关于方法参数的类型"><a href="#关于方法参数的类型" class="headerlink" title="关于方法参数的类型"></a>关于方法参数的类型</h3><p>值类型和引用类型都可以作为方法的参数。</p>
<p>值类型：将实参的值拷贝给形参，在方法内部对行参进行修改，不会影响实参。</p>
<p>引用类型参数：将实际参数的值拷贝给形参，此时实参和形参的值相同，所指向的堆内存是同一块区域，所以在方法内部修改形参的值，影响要实参。</p>
<h3 id="参数的修饰符"><a href="#参数的修饰符" class="headerlink" title="参数的修饰符"></a>参数的修饰符</h3><ul>
<li><p>ref     reference 引用，地址。用在值类型参数前，表示传递的是实参的地址给行参，而不是做值的拷贝，行参进行修改，会影响实参。递的是参数的地址。</p>
</li>
<li><p>out  输出参数，传递out类型的参数可以不进行初始化，在方法内部必须对out类型的参数改变值，调用完毕，通过实参接收输出参数的值。</p>
</li>
<li><p>params 修饰数组类型的参数，且放在方法的最后一个参数的位置，此时调用方法时可以传递数组对象，或者传递数组元素</p>
</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态的成员都是属于类的成员，和对象没关系，通过类名。成员名访问（统一个类中，）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> j; <span class="comment">//静态变量</span></span><br><span class="line">类名.j.  <span class="comment">//调用</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态成员不能用对象名调用，不能使用this</p>
<p>静态方法中要访问非静态成员一定要使用对象去访问（可以是传递进来的参数，也可是示例化的对象）</p>
<p>如果类是静态的，下面所有的变量都要是静态的，否则会报错</p>
</blockquote>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>方法的重载（Method Overloading）是指在同一个类中可以定义多个具有相同名称但参数列表不同的方法。通过方法重载，可以让同一个方法名称在不同的上下文中具有不同的行为，从而提高了代码的灵活性和可读性。</p>
<h3 id="空引用异常"><a href="#空引用异常" class="headerlink" title="空引用异常"></a>空引用异常</h3><p>C# 中的空引用异常（Null Reference Exception）是一种常见的运行时异常，通常在试图访问空对象或未初始化的引用时抛出。当您尝试对一个空引用（即值为 null 的引用）调用方法、访问属性或访问字段时，就会触发空引用异常。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p><strong>属性的定义</strong>：是一种封装思想，用来对封装类中的私有字段进行读和写。属于一种操作成员。</p>
<p><strong>属性的分类</strong></p>
<ul>
<li><strong>只读属性</strong>：只能读取到字段的值，不能给字段赋值，只有get访问器</li>
<li><strong>只写属性</strong>：只能对字段赋值，不能对字段读区，只有set访问器</li>
<li><strong>读写属性</strong>：可以对字段进行读写，有get，set两种访问器。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Age 属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">value</span> &lt;= <span class="number">150</span>) <span class="comment">// 简单的年龄验证</span></span><br><span class="line">            &#123;</span><br><span class="line">                age = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Age must be between 0 and 150.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li><p>访问的修饰符大多数是public</p>
</li>
<li><p>属性的类型和封装的字段类型一致</p>
</li>
<li><p>属性名和字段名相同，但是采用帕斯卡命名法，即单词的每个字首字母大写</p>
</li>
</ul>
<p><strong>lambda 表达式添加属性</strong></p>
<p>在成员变量上点灯泡，封装字段并使用属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">double</span> Price &#123; <span class="keyword">get</span> =&gt; price; <span class="keyword">set</span> =&gt; price = <span class="keyword">value</span>; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>索引器也是一种封装思想，主要是用来封装对于类中数组元素的操作。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] data = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]; <span class="comment">// 假设这是我们要管理的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引器的声明与属性类似，但使用 this 关键字指定索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> data[index]; <span class="comment">// 索引器的 get 访问器用于获取特定索引处的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            data[index] = <span class="keyword">value</span>; <span class="comment">// 索引器的 set 访问器用于设置特定索引处的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myObject = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用索引器设置和获取数据</span></span><br><span class="line">        myObject[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 设置索引为0处的值为10</span></span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = myObject[<span class="number">0</span>]; <span class="comment">// 获取索引为0处的值</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>); <span class="comment">// 输出10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>为了减少重复的代码，我们使用继承。</p>
<p>继承的特点</p>
<ul>
<li><p>继承的传递性：可以从任意的父类访问成员</p>
</li>
<li><p>继承的单根性：只能有一个父类，不能有多个父类</p>
</li>
</ul>
<p>继承的优点</p>
<ul>
<li>模拟了现实世界的关系</li>
<li>实现代码的复用</li>
<li>结构关系更清晰</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义一个父类</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Student</span>:<span class="title">Person</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意：实例化子类对象时，在调用子类的构造方法之前，默认先调用父类的无参构造方法</p>
</blockquote>
<h3 id="base关键字"><a href="#base关键字" class="headerlink" title="base关键字"></a>base关键字</h3><p>使用base关键字，强制调用父类中制定的构造方法</p>
<blockquote>
<p> protected 修饰符：父类中的成员在子类中只能通过子类对象访问，无法通过父类对象访问</p>
</blockquote>
<p>示例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">HRSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明变量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> education;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//带name，qulification的构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> education</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.education = education;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个显示信息的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;姓名：<span class="subst">&#123;name&#125;</span>\t学历：<span class="subst">&#123;education&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Programmer</span>:<span class="title">Employee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> languages;</span><br><span class="line">        <span class="built_in">string</span> os;</span><br><span class="line">        <span class="built_in">string</span> database;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义构造函数</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="title">Programmer</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">string</span> education,<span class="built_in">string</span> languages,<span class="built_in">string</span> os,<span class="built_in">string</span> database</span>)</span></span><br><span class="line"><span class="function">            :<span class="title">base</span>(<span class="params">name,education</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">this</span>.languages = languages;</span><br><span class="line">            <span class="keyword">this</span>.os = os;</span><br><span class="line">            <span class="keyword">this</span>.database = database;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示程序员信息</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMSG</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;姓名：<span class="subst">&#123;name&#125;</span>学历：<span class="subst">&#123;education&#125;</span>语言：<span class="subst">&#123;languages&#125;</span>操作系统<span class="subst">&#123;os&#125;</span>数据库：<span class="subst">&#123;database&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>不同的的子类对象在运行时调用不同子类中的同名方法</p>
<p><strong>实现多态的方法</strong></p>
<ul>
<li>抽象方法</li>
<li>虚方法</li>
<li>接口</li>
</ul>
<p><strong>seale关键字</strong></p>
<p>密封类不允许被继承</p>
<p>static 静态方法不能被重写的</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>根据里氏替换原则，可以创建一个父类的数组，保存子类对象到数组中</p>
<p>强制转换，如果转换失败，会抛出一个异常。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个矩形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Area</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Width * Height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个正方形类，继承自矩形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Square</span> : <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _side;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正方形的边长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Side</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _side; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _side = <span class="keyword">value</span>;</span><br><span class="line">            Width = Height = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Square();</span><br><span class="line">        rectangle.Width = <span class="number">5</span>;</span><br><span class="line">        rectangle.Height = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果使用了里氏替换原则，下面的输出结果应该是20</span></span><br><span class="line">        <span class="comment">// 因为正方形是矩形的子类型，所以可以用正方形替换矩形</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;矩形的面积：&quot;</span> + rectangle.Area());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构造方法的多态性"><a href="#构造方法的多态性" class="headerlink" title="构造方法的多态性"></a>构造方法的多态性</h3><p>在 C# 中，当你写下 <code>Class1 obj = new Class2();</code> 这样的语句时，你实际上是在创建一个名为 <code>obj</code> 的对象，其类型是 <code>Class1</code>，但是你使用的是 <code>Class2</code> 类的构造函数来初始化这个对象。</p>
<p>这种行为在面向对象编程中称为多态性（Polymorphism）。它是面向对象编程中的一个重要定义，允许你使用基类的引用来引用子类的对象，从而实现了代码的灵活性和可扩展性。</p>
<p>具体来说，假设 <code>Class2</code> 是 <code>Class1</code> 的子类，那么你可以将 <code>Class2</code> 的对象赋值给 <code>Class1</code> 类型的变量，因为 <code>Class2</code> 是 <code>Class1</code> 的一个特例。这样的赋值是允许的，因为 <code>Class2</code> 继承了 <code>Class1</code> 的所有成员，所以它具有与 <code>Class1</code> 相同的行为和属性，但可能会添加一些额外的功能或重写一些方法。</p>
<h3 id="抽象方法-abstract"><a href="#抽象方法-abstract" class="headerlink" title="抽象方法 abstract"></a>抽象方法 abstract</h3><ul>
<li>在父类定义的一个没有实现的方法</li>
<li>抽象方法一定要定义在抽象类中</li>
<li>子类继承自一个抽象父类，这一定要重写父类中的抽象方法，使用override显示重写</li>
<li>抽象类本身不能实例化</li>
</ul>
<blockquote>
<p>小结：使用抽象方法的好处是约束子类的行为，在不同子类中有</p>
</blockquote>
<p>示例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个抽象动物类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个狗类，继承自动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;狗发出汪汪的声音&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个猫类，也继承自动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;猫发出喵喵的声音&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Animal animal1 = <span class="keyword">new</span> Dog();</span><br><span class="line">        Animal animal2 = <span class="keyword">new</span> Cat();</span><br><span class="line">        animal1.MakeSound(); <span class="comment">// 输出：狗发出汪汪的声音</span></span><br><span class="line">        animal2.MakeSound(); <span class="comment">// 输出：猫发出喵喵的声音</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="virtual虚方法"><a href="#virtual虚方法" class="headerlink" title="virtual虚方法"></a>virtual虚方法</h3><p>在父类中定义一个有实现的方法，他可以在子类中被重写，也可以不被重写</p>
<p>抽象方法和虚方法的区别 </p>
<ul>
<li>抽象方法没有方法体，虚方法有方法体</li>
<li>抽象方法一定要重写，虚方法可以重写也可以不重写</li>
<li>抽象方法必须定义在抽象类中，虚方法可以定义在抽象类或普通类中</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>接口是一组规范和标准。在接口中定义一组规范和标准，是没有具体实现的，由类进行实现，从而约束类的行为</p>
<h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><ul>
<li><p>接口的成员一般没有访问修饰符，是公开的</p>
</li>
<li><p>接口无法实例化，但是我们可以创建接口类型的变量去指向实现接口的对象</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Itest test = <span class="keyword">new</span> Test();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接口的成员只能是属性，索引器，方法，在新的.net版本方法可以用括号</p>
</li>
<li><p>一个类可以实现多个接口</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Test</span>:<span class="title">ITest1</span>,<span class="title">ITest2</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的应用场景"><a href="#接口的应用场景" class="headerlink" title="接口的应用场景"></a>接口的应用场景</h3><p>接口作为方法的参数去使用，可以传递任意一个实现了接口的对象</p>
<p>接口作为方法的返回值使用，可以返回的是任意实现接口的对象</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>接口名称的命名规则：一般以I打头，后面的单词用帕斯卡命名法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ITest</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口使用，定义一个类去实现接口</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Test</span>:<span class="title">ITest</span> <span class="comment">//接口和类是实现的关系</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ul>
<li>如果一个类去实现接口，则必须对接口中的所有未实现的成员进行实现</li>
<li>接口无法实例化</li>
<li>一个类可以实现多个接口，多个接口之间用逗号分隔</li>
<li>一个类继承基类，又实现接口时，接口必须放在最前面</li>
<li>一个类实现接口时，如果接口有其他同名的成员，可以使用显式实现接口，此时需要通过接口类型去调用方法，不能使用实现类对象去调用。</li>
<li>接口之间可以多继承，一个接口可以继承多个接口。</li>
</ul>
<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>字符串构造原理</p>
<p>string是c#语言定义字符串的关键字</p>
<p>String是.NET中的字符串的类型定义字符串的方式</p>
<p>字符串的暂存池（常量池）</p>
<p>通过声明式定义的字符串会保存在CLR的暂存池中，在程序运行中，声明的字符串会先在暂存池中检查，看是否有需要的字符串，如果有的话，直接获得暂存池中字符串的地址，不会分配新的内存空间。</p>
<p>string具有不可变的特点</p>
<p>如果对string类型的字符串进行任何的操作，导致字符串的值发生改变的，不会在原来的内存空间中修改字符串的值，而是会重新开辟新的内存空间</p>
<p>string.Empty与””,null的区别</p>
<p>string.Empty与”” :分配了内存地址，只是内存中没有任何字符<br>null:空引用，没有分配内存地址</p>
<h3 id="创建字符串的方式"><a href="#创建字符串的方式" class="headerlink" title="创建字符串的方式"></a>创建字符串的方式</h3><p>声明式，放在常量池</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>构造式，使用new，会重新分配存储空间</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str3 = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="built_in">char</span>[]&#123;<span class="string">&quot;h&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h3><p>静态方法</p>
<p>**Compare()**用于比较两个字符串的方法，它返回一个整数，表示两个字符串的相对顺序。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(String.Compare(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>)); <span class="comment">//0123456789aAbB....</span></span><br></pre></td></tr></table></figure>

<p>**Concat()**拼接字符串</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(String.Concat(s1,s2));</span><br></pre></td></tr></table></figure>

<p>**Equals()**比较字符串的值是否相等</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(String.Equals(s1,s2));</span><br></pre></td></tr></table></figure>

<p>**Format()**格式化字符串</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(String.Format(<span class="string">&quot;s1的值是&#123;0&#125;,s2的值是&#123;1&#125;&quot;</span>, s1,s2));</span><br><span class="line">Console.WriteLine(String.Format(<span class="string">&quot;&#123;0:P&#125;&quot;</span>,<span class="number">123.005</span>));</span><br><span class="line">Console.WriteLine(String.Format(<span class="string">&quot;&#123;0:C&#125;&quot;</span>, <span class="number">123.005</span>));</span><br><span class="line">Console.WriteLine(String.Format(<span class="string">&quot;&#123;0:F2&#125;&quot;</span>, <span class="number">123.508</span>));</span><br><span class="line">Console.WriteLine(String.Format(<span class="string">&quot;&#123;0:yyyy-MM-dd&#125;&quot;</span>, DateTime.Now));</span><br><span class="line">Console.WriteLine(String.Format(<span class="string">&quot;&#123;0:yyyy年MM月dd&#125;&quot;</span>, DateTime.Now));</span><br></pre></td></tr></table></figure>

<p>**IsNullOrEmpty()**检查一个字符串是否为 null 或者为空字符串。如果字符串为 null 或者空字符串（长度为 0），则返回 true，否则返回 false。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s3 =<span class="string">&quot;    &quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.IsNullOrEmpty(s3)); <span class="comment">//&quot;&quot;, string.Empty, null</span></span><br></pre></td></tr></table></figure>

<p>**IsNullOrWhiteSpace()**方法在检查字符串是否为 null 或者为空字符串的基础上，还会额外检查字符串是否只包含空白字符（如空格、制表符、换行符等）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="built_in">string</span>.IsNullOrWhiteSpace(s3)); <span class="comment">//&quot;&quot;, string.Empty, null, 空白字符</span></span><br></pre></td></tr></table></figure>

<p>**Join()**按照指定的分隔符串联字符串</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(String.Join(<span class="string">&#x27; &#x27;</span>,s1,s2));</span><br></pre></td></tr></table></figure>

<p>实例方法</p>
<p>**Contains()**测试字符串是否包含指定的字符或字符串，返回布尔值</p>
<p>**StartsWith()**测试是否以指定的字符串开头，返回布尔值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>**EndsWith()**测试是否以指定的字符串结尾</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] names = &#123; <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;TOM&quot;</span>, <span class="string">&quot;lucy&quot;</span>, <span class="string">&quot;ROSe&quot;</span>, <span class="string">&quot;tonny&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> item <span class="keyword">in</span> names)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>[] names = &#123; <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;TOM&quot;</span>, <span class="string">&quot;lucy&quot;</span>, <span class="string">&quot;ROSe&quot;</span>, <span class="string">&quot;tonny&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> item <span class="keyword">in</span> names)</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;包含o的姓名：&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (item.ToLower().Contains(<span class="string">&quot;o&quot;</span>))</span><br><span class="line">		Console.WriteLine(item);</span><br><span class="line"></span><br><span class="line">		Console.WriteLine(<span class="string">&quot;以t打头的姓名：&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (item.StartsWith(<span class="string">&quot;t&quot;</span>))</span><br><span class="line">		Console.WriteLine(item);</span><br><span class="line"></span><br><span class="line">		Console.WriteLine(<span class="string">&quot;以y结尾的姓名：&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (item.EndsWith(<span class="string">&quot;y&quot;</span>))</span><br><span class="line">		Console.WriteLine(item);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (item.IndexOf(<span class="string">&quot;o&quot;</span>) != <span class="number">-1</span>)</span><br><span class="line">		Console.WriteLine(item);</span><br><span class="line">		Console.<span class="function">Wr	<span class="title">iteLine</span>(<span class="params"><span class="string">&quot;----------------------------&quot;</span></span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**IndexOf()**测试字符串在指定字符串是第一次匹配成功时的位置 ，从0开始,没有查找到，则返回-1</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(s1.IndexOf(<span class="string">&quot;l&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>**LastIndexOf()**测试字符串在指定字符串是最后一次匹配成功时的位置</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(s1.LastIndexOf(<span class="string">&quot;l&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>**PadLeft()**用于在字符串的左侧填充指定字符，以使字符串达到指定的长度的方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> paddedStr2 = str.PadLeft(<span class="number">5</span>, <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 使用 &#x27;0&#x27; 填充</span></span><br></pre></td></tr></table></figure>

<p>**PadRight()**用于在字符串的右侧填充指定字符，以使字符串达到指定的长度的方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(s1.PadLeft(<span class="number">20</span>,<span class="string">&#x27;*&#x27;</span>));<span class="comment">//右对齐，在左边填充</span></span><br><span class="line">Console.WriteLine(s1.PadRight(<span class="number">20</span>,<span class="string">&#x27;*&#x27;</span>));<span class="comment">//左对齐</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;1500&quot;</span>);</span><br><span class="line">Console.Write(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">Console.Write(<span class="string">&quot;5&quot;</span>.PadLeft(<span class="number">3</span>));</span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n-----------------&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>**Split()**按指定的分隔符对字符串进行拆分，返回的拆分以后的数组</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> email = <span class="string">&quot;jacky@163.com&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(email.Contains(<span class="string">&#x27;@&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span>[] array = email.Split(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">	Console.WriteLine(array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(email.Substring(<span class="number">0</span>, email.IndexOf(<span class="string">&quot;@&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>**Substring()**从指定的下标位置处取子字符串，省略长度，一直取到最后</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(s1.Substring(<span class="number">1</span>));</span><br><span class="line">Console.WriteLine(s1.Substring(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">ToLower()</span><br></pre></td></tr></table></figure>

<p>**ToCharArray()**把字符串转换为字符数组</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>[] chars=s1.ToCharArray();</span><br><span class="line">把字符数组转换为字符串</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="keyword">new</span> <span class="built_in">string</span>(chars);</span><br><span class="line">Console.WriteLine(s3);</span><br></pre></td></tr></table></figure>

<p>**ToLower()**转换为小写</p>
<p>**ToUpper()**转换为大写</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;names.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(names[i].Substring(<span class="number">0</span>,<span class="number">1</span>).ToUpper() + names[i].Substring(<span class="number">1</span>).ToLower());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**Trim()**去除字符串的前后空白字符</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(String.Concat(s1.Trim(), s2));</span><br><span class="line">\t \n</span><br><span class="line"><span class="built_in">string</span> path = <span class="string">@&quot;G:\20240325班级\1 - C#\DAY09-4.15\01-代码\MySolution0415\Demo002\bin\Debug\net6.0\Demo003.exe&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> i = path.LastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>;</span><br><span class="line">Console.WriteLine(path.Substring(i));</span><br></pre></td></tr></table></figure>

<p>**Remove()**删除</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Remove()</span></span><br><span class="line"><span class="built_in">string</span> newStr =s1.Remove(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">Console.WriteLine(s1);</span><br><span class="line">Console.WriteLine(newStr);</span><br></pre></td></tr></table></figure>

<h3 id="StringBuilder可变字符串"><a href="#StringBuilder可变字符串" class="headerlink" title="StringBuilder可变字符串"></a>StringBuilder可变字符串</h3><p><code>StringBuilder</code> 是 .NET 中用于处理可变字符串的类，它位于 <code>System.Text</code> 命名空间中。与 <code>string</code> 类型不同，<code>StringBuilder</code> 允许你对字符串进行动态修改而不需要创建新的字符串对象，这在处理大量字符串拼接或者频繁修改字符串时能够提升性能。</p>
<p>主要特点</p>
<ol>
<li><p><strong>可变性</strong>：<code>StringBuilder</code> 允许在字符串中插入、追加、删除和替换字符，而不会创建新的字符串实例。</p>
</li>
<li><p><strong>性能</strong>：由于 <code>StringBuilder</code> 是可变的，所以在对字符串进行频繁操作时，避免了创建大量的临时字符串对象，从而提高了性能。</p>
</li>
</ol>
<p>常用方法</p>
<p><strong>Append</strong>: 将指定内容追加到字符串的末尾。</p>
<p><strong>nsert</strong>: 在指定位置插入指定内容。</p>
<p><strong>Remove</strong>: 从指定位置开始删除指定数量的字符。</p>
<p><strong>Replace</strong>: 替换字符串中的指定内容。</p>
<p><strong>Clear</strong>: 清空字符串内容。</p>
<p><strong>ToString</strong>: 将 <code>StringBuilder</code> 对象转换为 <code>string</code> 类型。</p>
<p><strong>Capacity</strong>: 获取或设置 <code>StringBuilder</code> 对象的容量。</p>
<p>#示例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加字符串</span></span><br><span class="line">sb.Append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入字符串</span></span><br><span class="line">sb.Insert(<span class="number">5</span>, <span class="string">&quot; World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换字符串</span></span><br><span class="line">sb.Replace(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hi&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除字符</span></span><br><span class="line">sb.Remove(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最终字符串</span></span><br><span class="line"><span class="built_in">string</span> result = sb.ToString(); <span class="comment">// 输出为 &quot;Hi World&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个 <code>StringBuilder</code> 对象 <code>sb</code>，然后通过 <code>Append</code>、<code>Insert</code>、<code>Replace</code> 和 <code>Remove</code> 方法对字符串进行了修改，最后通过 <code>ToString</code> 方法将 <code>StringBuilder</code> 对象转换为 <code>string</code> 类型的结果。这个例子展示了 <code>StringBuilder</code> 的基本用法，它可以动态地构建和修改字符串而不会产生大量的临时字符串对象。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>在 C# 中，正则表达式（Regular Expression，简称 Regex）是一个强大的工具，用于处理字符串的匹配、搜索和替换。C# 中的正则表达式由 <code>System.Text.RegularExpressions</code> 命名空间提供支持，其中包含了 <code>Regex</code> 类，用于处理正则表达式。</p>
<p>以下是一些在 C# 中使用正则表达式的常见操作：</p>
<h3 id="创建正则表达式对象"><a href="#创建正则表达式对象" class="headerlink" title="创建正则表达式对象"></a>创建正则表达式对象</h3><p>要使用正则表达式，首先需要创建一个 <code>Regex</code> 对象，可以使用 <code>Regex</code> 类的静态方法 <code>Regex.Compile</code> 或者 <code>Regex</code> 构造函数来创建。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Regex regex = <span class="keyword">new</span> Regex(<span class="string">@&quot;\d+&quot;</span>); <span class="comment">// 匹配一个或多个数字</span></span><br></pre></td></tr></table></figure>

<h3 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h3><p>可以使用 <code>Regex.IsMatch</code> 方法来判断一个字符串是否匹配指定的正则表达式。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> input = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="built_in">bool</span> isMatch = regex.IsMatch(input); <span class="comment">// 判断 input 是否符合 @&quot;\d+&quot; 的模式</span></span><br></pre></td></tr></table></figure>

<h3 id="获取匹配结果"><a href="#获取匹配结果" class="headerlink" title="获取匹配结果"></a>获取匹配结果</h3><p>可以使用 <code>Match</code> 对象来获取匹配的结果，包括匹配的字符串、位置等信息。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Match match = regex.Match(input);</span><br><span class="line"><span class="keyword">if</span> (match.Success)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> matchedString = match.Value; <span class="comment">// 获取匹配的字符串</span></span><br><span class="line">    <span class="built_in">int</span> startIndex = match.Index; <span class="comment">// 获取匹配的起始位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找所有匹配"><a href="#查找所有匹配" class="headerlink" title="查找所有匹配"></a>查找所有匹配</h3><p>可以使用 <code>Regex.Matches</code> 方法来查找输入字符串中所有匹配的子串。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> input = <span class="string">&quot;12345 67890&quot;</span>;</span><br><span class="line">MatchCollection matches = regex.Matches(input);</span><br><span class="line"><span class="keyword">foreach</span> (Match match <span class="keyword">in</span> matches)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(match.Value); <span class="comment">// 输出所有匹配的子串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="替换匹配的字符串"><a href="#替换匹配的字符串" class="headerlink" title="替换匹配的字符串"></a>替换匹配的字符串</h3><p>可以使用 <code>Regex.Replace</code> 方法来替换输入字符串中匹配的子串。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> input = <span class="string">&quot;I have 123 apples.&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> result = regex.Replace(input, <span class="string">&quot;XXX&quot;</span>); <span class="comment">// 将匹配的数字替换为 &quot;XXX&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上是一些常见的使用方式，正则表达式在 C# 中还有更多的高级用法和特性，例如捕获组、零宽断言、贪婪与非贪婪匹配等。正则表达式是一项非常强大和灵活的技术，能够满足各种复杂的字符串匹配和处理需求。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul>
<li>示例错误<ul>
<li>无法运行</li>
<li>易于确定，是编译时确定的错误，编译不成功</li>
</ul>
</li>
<li>逻辑错误<ul>
<li>错误的算法，错误的公式导致程序运行的结果和期望的结果不一致，难以确定</li>
<li>调试方法：断点调试（Debug）</li>
</ul>
</li>
<li>运行时错误<ul>
<li>编译没有错误，由于激发了系统的错误条件</li>
<li>比如数组越界，空引用异常</li>
</ul>
</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul>
<li>在关键语句去打断点</li>
<li>在Debug模式下进行断点调试（F5）</li>
<li>在调试过程中，可以使用逐语句F11，逐过程F10进行调试</li>
<li>可以观察局部变量窗口，监视窗口或即时窗口观察关键变量的变化过程，（没有的话，在调试菜单下找）</li>
<li>如果已确定出逻辑错误的语句，可以跳出调试Shift+F11</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>在C#中，异常是指程序执行过程中遇到的错误或意外情况。异常处理是一种用于处理这些错误的机制，它允许你在发生异常时采取适当的措施，以确保程序的稳定性和可靠性。以下是C#中异常处理的基本定义和用法：</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li><p>在程序运行时，由于意外的数据导致程序崩溃，就称为异常</p>
</li>
<li><p>在程序运行中，必须对有可能产生异常的语句进行处理的</p>
</li>
<li><p>引发异常的方式</p>
<ul>
<li>使用语句或表达式在执行过程中激发了某个异常的条件，使得操作无法正常结束，从而引发异常</li>
<li>使用显式throw语句来引发异常</li>
</ul>
</li>
</ul>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p>异常基类是Exception，两个子类</p>
<ul>
<li>SystemException：由于激发了公共运行库的异常条件导致的异常，一般是致命性的。</li>
<li>ApplicationException：应用程序异常，作为自定义异常的基类，非致命性的。</li>
</ul>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p><strong>异常类</strong>：C#中的异常是由系统定义的异常类的实例表示的，这些异常类都继承自<code>System.Exception</code>类。常见的异常类包括<code>ArgumentException</code>（参数错误）、<code>InvalidOperationException</code>（操作无效）、<code>NullReferenceException</code>（空引用异常）等。</p>
<p><strong>抛出异常</strong>：你可以使用<code>throw</code>关键字手动抛出异常。当遇到程序错误或不符合预期的情况时，可以抛出异常来中断程序的执行并将控制权传递给异常处理程序。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;发生了错误&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>捕获异常</strong>：使用<code>try-catch</code>语句可以捕获和处理异常。<code>try</code>块包含可能引发异常的代码，而<code>catch</code>块用于处理异常。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>finally块</strong>：<code>finally</code>块中的代码在<code>try</code>块中的代码执行结束后始终执行，无论是否发生异常。通常用于释放资源或执行清理操作。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行清理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多重catch块</strong>：一个<code>try</code>块可以包含多个<code>catch</code>块，用于处理不同类型的异常。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArgumentException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理 ArgumentException 异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvalidOperationException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理 InvalidOperationException 异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理其他类型的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义异常</strong>：除了使用系统定义的异常类，你还可以创建自定义的异常类来表示特定的错误或异常情况。自定义异常类通常继承自<code>System.Exception</code>类。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomException</span> : <span class="title">Exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span>(<span class="params"><span class="built_in">string</span> message</span>) : <span class="title">base</span>(<span class="params">message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些是C#中异常处理的基本定义和用法。异常处理是编写稳健和可靠代码的重要组成部分，它可以帮助你有效地处理程序运行过程中的错误和异常情况。</p>
<h3 id="throw引发异常"><a href="#throw引发异常" class="headerlink" title="throw引发异常"></a>throw引发异常</h3><p>在 C# 中，<code>throw</code> 关键字用于手动引发异常。通过 <code>throw</code> 关键字，你可以在代码中显式地抛出异常，从而中断程序的执行并将控制权传递给异常处理程序。下面是 <code>throw</code> 关键字的基本用法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;发生了错误&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码将抛出一个 <code>Exception</code> 类型的异常，并且指定了异常的消息为 <code>&quot;发生了错误&quot;</code>。你可以根据需要选择合适的异常类型，并且可以提供自定义的异常消息。例如，你可以使用特定的异常类，如 <code>ArgumentException</code>、<code>InvalidOperationException</code>，或者创建自定义的异常类来表示特定的错误或异常情况。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用特定的异常类</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义的异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CustomException</span> : <span class="title">Exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span>(<span class="params"><span class="built_in">string</span> message</span>) : <span class="title">base</span>(<span class="params">message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">&quot;自定义异常消息&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在实际开发中，你可以根据具体的情况在适当的地方使用 <code>throw</code> 关键字来引发异常，例如在输入参数验证失败时、不支持的操作时、或者其他不符合预期的情况下。引发异常有助于提高代码的可靠性和可维护性，同时也方便了程序员在调试和测试阶段发现问题。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p>在 C# 中，集合（Collection）是用于存储和操作一组对象的数据结构。集合提供了一种更灵活、更方便的方式来管理多个对象，而不需要显式地管理内存分配和释放。C# 中常用的集合类包括泛型集合（Generic Collections）和非泛型集合（Non-generic Collections）。</p>
<h3 id="泛型集合（Generic-Collections）"><a href="#泛型集合（Generic-Collections）" class="headerlink" title="泛型集合（Generic Collections）"></a>泛型集合（Generic Collections）</h3><p>泛型集合是 .NET Framework 提供的强类型集合，它们使用泛型来指定集合中元素的类型，从而提供了类型安全和高效的存储和检索操作。常见的泛型集合包括：</p>
<ol>
<li>**List<T>**：动态数组，可以动态增长和缩减，用于存储列表数据。</li>
<li>**Dictionary&lt;TKey, TValue&gt;**：键值对集合，用于存储键值对数据，通过键快速查找值。</li>
<li>**HashSet<T>**：无重复元素集合，用于存储唯一的元素。</li>
<li>**Queue<T>**：先进先出（FIFO）队列，用于存储元素，并支持在队列的一端插入元素，在另一端移除元素。</li>
<li>**Stack<T>**：后进先出（LIFO）堆栈，用于存储元素，并支持在堆栈的顶部插入元素和移除元素。</li>
</ol>
<h3 id="非泛型集合（Non-generic-Collections）"><a href="#非泛型集合（Non-generic-Collections）" class="headerlink" title="非泛型集合（Non-generic Collections）"></a>非泛型集合（Non-generic Collections）</h3><p>非泛型集合是 .NET Framework 中早期的集合实现，它们不具有类型安全性，通常在早期版本的 .NET Framework 中使用。一般来说，推荐优先使用泛型集合而不是非泛型集合。常见的非泛型集合包括：</p>
<ol>
<li><strong>ArrayList</strong>：动态数组，与 List<T> 类似，但它可以存储任意类型的对象。</li>
<li><strong>Hashtable</strong>：哈希表，键值对集合，用于存储键值对数据，类似于 Dictionary&lt;TKey, TValue&gt;，但不具有类型安全性。</li>
<li><strong>Queue</strong>：先进先出（FIFO）队列，与 Queue<T> 类似，但它可以存储任意类型的对象。</li>
<li><strong>Stack</strong>：后进先出（LIFO）堆栈，与 Stack<T> 类似，但它可以存储任意类型的对象。</li>
</ol>
<p>总的来说，泛型集合提供了更安全、更高效的集合操作，而非泛型集合则是 .NET Framework 中较早的集合实现，在特定情况下仍然可以使用。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><code>ArrayList</code> 是 C# 中的一种动态数组，它可以根据需要自动增长或缩小大小，以容纳添加或删除的元素。<code>ArrayList</code> 位于 <code>System.Collections</code> 命名空间下。</p>
<h3 id="ArrayList特性和用途"><a href="#ArrayList特性和用途" class="headerlink" title="ArrayList特性和用途"></a>ArrayList特性和用途</h3><ol>
<li><strong>动态大小：</strong> <code>ArrayList</code> 的大小可以根据需要动态调整，因此你无需在使用前指定其大小。</li>
<li><strong>异构性：</strong> <code>ArrayList</code> 可以包含不同类型的元素，例如整数、字符串、对象等。</li>
<li><strong>索引访问：</strong> 与普通数组类似，你可以使用索引来访问 <code>ArrayList</code> 中的元素。</li>
<li><strong>丰富的方法：</strong> <code>ArrayList</code> 类提供了许多方法来操作元素，如添加 (<code>Add</code>)、插入 (<code>Insert</code>)、移除 (<code>Remove</code>)、清空 (<code>Clear</code>) 等。</li>
<li><strong>适用场景：</strong> <code>ArrayList</code> 适用于那些需要频繁添加或删除元素的情况，或者在编写代码时无法确定数组大小的情况。</li>
</ol>
<h3 id="ArrayList示例"><a href="#ArrayList示例" class="headerlink" title="ArrayList示例"></a>ArrayList示例</h3><p>创建 ArrayList 实例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 创建一个空的 ArrayList</span></span><br></pre></td></tr></table></figure>

<p>添加元素</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.Add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">list.Add(<span class="number">10</span>);</span><br><span class="line">list.Add(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>访问元素</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> item = list[<span class="number">0</span>]; <span class="comment">// 访问第一个元素</span></span><br></pre></td></tr></table></figure>

<p>修改元素</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[<span class="number">1</span>] = <span class="string">&quot;banana&quot;</span>; <span class="comment">// 修改第二个元素的值</span></span><br></pre></td></tr></table></figure>

<p>移除元素</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.Remove(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 移除指定的元素</span></span><br></pre></td></tr></table></figure>

<p>获取元素个数</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> count = list.Count; <span class="comment">// 获取 ArrayList 中元素的个数</span></span><br></pre></td></tr></table></figure>

<p>清空 ArrayList</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.Clear(); <span class="comment">// 清空 ArrayList 中的所有元素</span></span><br></pre></td></tr></table></figure>

<p>遍历 ArrayList</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ol>
<li>由于 <code>ArrayList</code> 存储的是 <code>object</code> 类型，因此在访问元素时需要进行类型转换。</li>
<li>当向 <code>ArrayList</code> 中添加大量元素时，可能会导致性能下降，因为它需要不断调整大小。在这种情况下，考虑使用 <code>List&lt;T&gt;</code> 进行替代，它提供了更好的性能和类型安全性。</li>
</ol>
<h3 id="HashTable-哈希表"><a href="#HashTable-哈希表" class="headerlink" title="HashTable 哈希表"></a>HashTable 哈希表</h3><p><code>Hashtable</code> 是 C# 中的一种集合，它提供了键值对的存储和检索功能，通过哈希表的方式实现快速的数据访问。<code>Hashtable</code> 位于 <code>System.Collections</code> 命名空间下。</p>
<p>特性和用途</p>
<ol>
<li><strong>键值对存储：</strong> <code>Hashtable</code> 存储的是键值对（key-value pairs），其中每个键都是唯一的。</li>
<li><strong>快速访问：</strong> 使用键来访问值时，<code>Hashtable</code> 可以在平均时间复杂度为 O(1) 的情况下实现快速检索。</li>
<li><strong>异构性：</strong> <code>Hashtable</code> 可以存储不同类型的键和值。</li>
<li><strong>动态调整大小：</strong> <code>Hashtable</code> 的大小可以根据需要动态调整。</li>
<li><strong>自动排序：</strong> <code>Hashtable</code> 不保证元素的顺序，而是根据哈希算法存储元素，因此它不是按照插入顺序来保存元素的。</li>
<li><strong>适用场景：</strong> <code>Hashtable</code> 适用于那些需要快速查找、插入和删除键值对的场景，特别是在不知道元素数量的情况下。</li>
</ol>
<p>示例</p>
<p>#创建 Hashtable 实例</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable(); <span class="comment">// 创建一个空的 Hashtable</span></span><br></pre></td></tr></table></figure>

<p>#添加键值对</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashtable.Add(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">hashtable.Add(<span class="number">2</span>, <span class="string">&quot;value2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>#访问值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> <span class="keyword">value</span> = hashtable[<span class="string">&quot;key1&quot;</span>]; <span class="comment">// 使用键来访问对应的值</span></span><br></pre></td></tr></table></figure>

<p>#修改值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashtable[<span class="string">&quot;key1&quot;</span>] = <span class="string">&quot;updated value&quot;</span>; <span class="comment">// 修改指定键对应的值</span></span><br></pre></td></tr></table></figure>

<p>#移除键值对</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashtable.Remove(<span class="string">&quot;key1&quot;</span>); <span class="comment">// 移除指定的键值对</span></span><br></pre></td></tr></table></figure>

<p>#获取键值对数量</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> count = hashtable.Count; <span class="comment">// 获取 Hashtable 中键值对的数量</span></span><br></pre></td></tr></table></figure>

<p>#清空 Hashtable</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashtable.Clear(); <span class="comment">// 清空 Hashtable 中的所有键值对</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ol>
<li>由于 <code>Hashtable</code> 存储的是 <code>object</code> 类型，因此在访问值时需要进行类型转换。</li>
<li>如果需要类型安全和性能更好的集合，可以考虑使用泛型集合，如 <code>Dictionary&lt;TKey, TValue&gt;</code>。</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h3><p>泛型是 C# 中的一个重要特性，它允许您编写能够与各种数据类型一起工作的灵活和可重用的代码。泛型使您能够编写与类型无关的代码，这意味着您可以编写一次代码，然后在许多不同的数据类型上使用它。</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类是一种具有一个或多个类型参数的类。类型参数允许您在实例化类时指定实际的数据类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T _value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyGenericClass</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _value = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetValue</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法是一种具有一个或多个类型参数的方法。类型参数允许您在调用方法时指定实际的数据类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">Add</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a, T b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口是一种具有一个或多个类型参数的接口。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRepository</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T entity</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Delete</span>(<span class="params">T entity</span>)</span>;</span><br><span class="line">    <span class="function">T <span class="title">GetById</span>(<span class="params"><span class="built_in">int</span> id</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>泛型约束允许您限制泛型类型参数的类型，从而提高泛型代码的灵活性和安全性。常见的约束包括 <code>where T : class</code>、<code>where T : struct</code>、<code>where T : new()</code> 等。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// T 必须是引用类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型优势"><a href="#泛型优势" class="headerlink" title="泛型优势"></a>泛型优势</h3><ul>
<li><strong>代码重用性</strong>：泛型使您能够编写与类型无关的代码，可以在多种数据类型上重用。</li>
<li><strong>类型安全</strong>：泛型提供了在编译时检查类型错误的能力，减少了在运行时出现类型错误的可能性。</li>
<li><strong>性能</strong>：泛型提供了更高的性能，因为它避免了装箱和拆箱操作。</li>
</ul>
<h3 id="泛型应用场景"><a href="#泛型应用场景" class="headerlink" title="泛型应用场景"></a>泛型应用场景</h3><ul>
<li><strong>集合类</strong>：例如 <code>List&lt;T&gt;</code>、<code>Dictionary&lt;TKey, TValue&gt;</code> 等。</li>
<li><strong>数据结构</strong>：例如栈、队列等。</li>
<li><strong>LINQ</strong>：Language Integrated Query（集成查询语言）中使用泛型。</li>
</ul>
<p>泛型是 C# 中的一项强大的特性，能够使您的代码更加灵活、可读、可维护，并提高性能和安全性。</p>
<h3 id="泛型集合：List"><a href="#泛型集合：List" class="headerlink" title="泛型集合：List&lt;&gt;"></a>泛型集合：List&lt;&gt;</h3><h3 id="List定义"><a href="#List定义" class="headerlink" title="List&lt;&gt;定义"></a>List&lt;&gt;定义</h3><p>泛型集合是 C# 中用于存储和操作数据的强大工具。<code>List&lt;T&gt;</code> 是其中最常用和最灵活的一种泛型集合类型。它允许您在运行时动态添加、删除和访问元素，并提供了丰富的方法和属性来方便地操作数据集合。</p>
<h3 id="List-的创建和初始化"><a href="#List-的创建和初始化" class="headerlink" title="List&lt;&gt; 的创建和初始化"></a>List&lt;&gt; 的创建和初始化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 List</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用初始化器初始化 List</span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt; names = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="添加和访问元素"><a href="#添加和访问元素" class="headerlink" title="添加和访问元素"></a>添加和访问元素</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">numbers.Add(<span class="number">10</span>);</span><br><span class="line">numbers.Add(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line"><span class="built_in">int</span> firstNumber = numbers[<span class="number">0</span>]; <span class="comment">// firstNumber = 10</span></span><br></pre></td></tr></table></figure>

<h3 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a>判断元素是否存在</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (names.Contains(<span class="string">&quot;Alice&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// List 中包含 &quot;Alice&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据索引删除元素</span></span><br><span class="line">names.RemoveAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据值删除元素</span></span><br><span class="line">names.Remove(<span class="string">&quot;Charlie&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取-List-的大小"><a href="#获取-List-的大小" class="headerlink" title="获取 List 的大小"></a>获取 List 的大小</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> count = names.Count;</span><br></pre></td></tr></table></figure>

<h3 id="遍历-List"><a href="#遍历-List" class="headerlink" title="遍历 List"></a>遍历 List</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空-List"><a href="#清空-List" class="headerlink" title="清空 List"></a>清空 List</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.Clear();</span><br></pre></td></tr></table></figure>

<p><code>List&lt;T&gt;</code> 是一种灵活且功能丰富的泛型集合类型，适用于许多场景，包括存储和操作各种类型的数据。它提供了丰富的方法和属性，能够方便地进行数据操作和管理。</p>
<h3 id="泛型集合：Dictionary"><a href="#泛型集合：Dictionary" class="headerlink" title="泛型集合：Dictionary&lt;&gt;"></a>泛型集合：Dictionary&lt;&gt;</h3><h3 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h3><p><code>Dictionary&lt;TKey, TValue&gt;</code> 是 C# 中的一个泛型集合类，用于存储键值对。它提供了高效的查找功能，允许您通过键快速检索到对应的值。每个键必须是唯一的，但值可以重复。</p>
<h3 id="Dictionary-的创建和初始化"><a href="#Dictionary-的创建和初始化" class="headerlink" title="Dictionary 的创建和初始化"></a>Dictionary 的创建和初始化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 Dictionary</span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; ages = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用初始化器初始化 Dictionary</span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; capitals = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Washington, D.C.&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;UK&quot;</span>, <span class="string">&quot;London&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;France&quot;</span>, <span class="string">&quot;Paris&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="添加和访问元素-1"><a href="#添加和访问元素-1" class="headerlink" title="添加和访问元素"></a>添加和访问元素</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">ages[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">ages[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line"><span class="built_in">int</span> aliceAge = ages[<span class="string">&quot;Alice&quot;</span>]; <span class="comment">// aliceAge = 30</span></span><br></pre></td></tr></table></figure>

<h3 id="判断键是否存在"><a href="#判断键是否存在" class="headerlink" title="判断键是否存在"></a>判断键是否存在</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ages.ContainsKey(<span class="string">&quot;Alice&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Alice 的年龄已经存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据键删除元素</span></span><br><span class="line">ages.Remove(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取-Dictionary-的大小"><a href="#获取-Dictionary-的大小" class="headerlink" title="获取 Dictionary 的大小"></a>获取 Dictionary 的大小</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> count = ages.Count;</span><br></pre></td></tr></table></figure>

<h3 id="获取-Dictionary-中的键和值"><a href="#获取-Dictionary-中的键和值" class="headerlink" title="获取 Dictionary 中的键和值"></a>获取 Dictionary 中的键和值</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有键</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> key <span class="keyword">in</span> ages.Keys)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有值</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> ages.Values)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值对</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> ages)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Key: <span class="subst">&#123;pair.Key&#125;</span>, Value: <span class="subst">&#123;pair.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清空-Dictionary"><a href="#清空-Dictionary" class="headerlink" title="清空 Dictionary"></a>清空 Dictionary</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages.Clear();</span><br></pre></td></tr></table></figure>

<p><code>Dictionary&lt;TKey, TValue&gt;</code> 是一个非常有用的数据结构，用于在 C# 中存储键值对，并提供了高效的查找功能。</p>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h3><p>委托是 C# 中一种非常强大的类型，它允许将方法作为参数传递给其他方法，或者将方法保存为对象，然后在需要时调用它们。委托提供了一种间接调用方法的机制，这对于实现事件处理、回调函数和异步编程等场景非常有用。</p>
<p>在 C# 中，委托是一种类型，可以看作是对方法的封装，它包含了一个方法的引用。委托的定义包括两个主要部分：委托类型和委托实例。</p>
<ul>
<li><strong>委托类型</strong>：委托类型定义了委托可以引用的方法的签名（返回类型和参数列表）。委托类型使用 <code>delegate</code> 关键字定义。例如：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个委托类型 <code>MyDelegate</code>，它可以引用一个没有返回值且接受一个 <code>int</code> 类型参数的方法。</p>
<ul>
<li><strong>委托实例</strong>：委托实例是委托类型的一个具体实例，它可以引用一个或多个具有相同签名的方法。委托实例可以通过将方法直接赋值给委托变量来创建，也可以通过委托的构造函数来创建。例如：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyDelegate myDelegate = SomeMethod;</span><br></pre></td></tr></table></figure>

<p>上面的代码创建了一个 <code>MyDelegate</code> 类型的委托实例 <code>myDelegate</code>，它引用了一个名为 <code>SomeMethod</code> 的方法。</p>
<h3 id="委托的使用"><a href="#委托的使用" class="headerlink" title="委托的使用"></a>委托的使用</h3><p>委托主要用于两个方面：委托作为方法参数和委托作为方法返回类型。</p>
<ol>
<li><strong>委托作为方法参数</strong>：在方法中可以将委托作为参数传递，允许调用方提供一个方法来执行某些操作。例如：</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessData</span>(<span class="params">MyDelegate del</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用委托</span></span><br><span class="line">    del(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>委托作为方法返回类型</strong>：方法可以返回委托类型，允许调用方获取一个方法的引用。例如：</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MyDelegate <span class="title">GetMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> SomeMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="委托的多播"><a href="#委托的多播" class="headerlink" title="委托的多播"></a>委托的多播</h3><p>委托可以引用多个方法，这种能力称为委托的多播。当调用委托时，它会依次调用引用的每个方法。可以使用 <code>+=</code> 运算符将多个方法添加到委托实例中，使用 <code>-=</code> 运算符将方法从委托实例中移除。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDelegate myDelegate = SomeMethod1;</span><br><span class="line">myDelegate += SomeMethod2; <span class="comment">// 将 SomeMethod2 添加到委托中</span></span><br><span class="line">myDelegate -= SomeMethod1; <span class="comment">// 将 SomeMethod1 从委托中移除</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>委托是 C# 中一种强大的类型，它提供了一种间接调用方法的机制。通过委托，可以将方法作为参数传递给其他方法，或者将方法保存为对象，然后在需要时调用它们。委托还支持多播，允许引用多个方法。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是 C# 中用于实现发布-订阅模式的重要机制，它允许一个对象通知其他对象发生了某个特定的事件，其他对象可以注册为该事件的监听器，并在事件发生时执行相应的操作。事件通常用于实现对象之间的解耦，使得对象能够以一种松散耦合的方式进行通信。</p>
<h3 id="事件的定义"><a href="#事件的定义" class="headerlink" title="事件的定义"></a>事件的定义</h3><p>事件是委托的一种特殊用法。在 C# 中，事件定义了委托的一个实例，通常包括两个部分：事件声明和事件触发器。</p>
<ul>
<li><strong>事件声明</strong>：事件声明定义了事件的名称和委托类型。它使用 <code>event</code> 关键字声明。例如：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个名为 <code>MyEvent</code> 的事件，它使用 <code>EventHandler</code> 委托作为事件的类型。</p>
<ul>
<li><strong>事件触发器</strong>：事件触发器用于触发事件，并通知所有注册的监听器。通常，事件触发器是一个专门的方法，负责触发事件。例如：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyEvent?.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个名为 <code>OnMyEvent</code> 的事件触发器，它使用 <code>EventArgs</code> 参数触发 <code>MyEvent</code> 事件。</p>
<h3 id="事件的使用"><a href="#事件的使用" class="headerlink" title="事件的使用"></a>事件的使用</h3><p>使用事件的主要步骤包括定义事件、注册事件处理程序和触发事件。</p>
<ol>
<li><p><strong>定义事件</strong>：首先，在类中定义事件，声明事件的名称和类型。</p>
</li>
<li><p><strong>注册事件处理程序</strong>：其他对象可以注册为事件的监听器，以便在事件发生时执行相应的操作。通常使用 <code>+=</code> 运算符将事件处理程序添加到事件中。</p>
</li>
<li><p><strong>触发事件</strong>：在事件发生时，调用事件触发器方法，通知所有注册的事件处理程序。</p>
</li>
</ol>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，演示了如何使用事件：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEvent?.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PublishEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Publishing event...&quot;</span>);</span><br><span class="line">        OnMyEvent(EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 事件处理程序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Event handled by Subscriber.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber subscriber = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册事件处理程序</span></span><br><span class="line">        publisher.MyEvent += subscriber.HandleEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        publisher.PublishEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Publisher</code> 类定义了一个名为 <code>MyEvent</code> 的事件，并提供了一个方法 <code>PublishEvent</code> 来触发该事件。<code>Subscriber</code> 类定义了一个事件处理程序 <code>HandleEvent</code>，用于处理事件。在 <code>Main</code> 方法中，创建了一个 <code>Publisher</code> 对象和一个 <code>Subscriber</code> 对象，并将 <code>Subscriber</code> 的 <code>HandleEvent</code> 方法注册为 <code>Publisher</code> 的事件处理程序。最后，调用 <code>PublishEvent</code> 方法触发事件，<code>Subscriber</code> 对象的事件处理程序被调用。</p>
<h3 id="事件的特点"><a href="#事件的特点" class="headerlink" title="事件的特点"></a>事件的特点</h3><ul>
<li><p><strong>安全性</strong>：事件是基于委托的，委托具有封装性和安全性，可以确保事件只能由定义它的类触发。</p>
</li>
<li><p><strong>解耦</strong>：事件允许对象之间以松散耦合的方式进行通信，提高了代码的可维护性和可扩展性。</p>
</li>
<li><p><strong>多播</strong>：事件支持多播委托，可以将多个事件处理程序注册到同一个事件上，以便在事件发生时依次调用它们。</p>
</li>
</ul>
<p>总的来说，事件是 C# 中一种非常有用的机制，用于实现发布-订阅模式，允许对象之间以松散耦合的方式进行通信。通过事件，可以更灵活地设计和实现应用程序。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>在 C# 中，I&#x2F;O（Input&#x2F;Output）流是用于在程序和外部数据源之间进行数据传输的重要机制。I&#x2F;O 流主要用于读取和写入文件、网络通信、处理内存流等操作。C# 提供了丰富的类库和接口，用于支持各种类型的 I&#x2F;O 操作。</p>
<h3 id="主要的-I-O-流类"><a href="#主要的-I-O-流类" class="headerlink" title="主要的 I&#x2F;O 流类"></a>主要的 I&#x2F;O 流类</h3><p>在 C# 中，常用的 I&#x2F;O 流类主要包括 <code>FileStream</code>、<code>StreamReader</code>、<code>StreamWriter</code>、<code>MemoryStream</code>、<code>NetworkStream</code> 等。下面是这些类的简要介绍：</p>
<ol>
<li><p><strong>FileStream</strong>：用于读取和写入文件的流。它直接操作文件系统，可以读取和写入任何类型的文件。</p>
</li>
<li><p><strong>StreamReader</strong>：用于从文本文件中读取字符流的流。它提供了各种读取文本文件的方法，例如逐行读取、读取到指定字符等。</p>
</li>
<li><p><strong>StreamWriter</strong>：用于向文本文件中写入字符流的流。它提供了各种写入文本文件的方法，例如写入字符串、写入字符数组等。</p>
</li>
<li><p><strong>MemoryStream</strong>：用于在内存中操作数据的流。它可以将数据读取到内存中，也可以将内存中的数据写入到流中。</p>
</li>
<li><p><strong>NetworkStream</strong>：用于与网络套接字进行数据交换的流。它可以用于与远程主机进行通信，发送和接收数据。</p>
</li>
</ol>
<h3 id="FileStream"><a href="#FileStream" class="headerlink" title="FileStream"></a>FileStream</h3><p><code>FileStream</code> 类的父类是 <code>Stream</code>。<code>Stream</code> 是抽象基类，定义了一些抽象方法和属性，用于在不同的 I&#x2F;O 操作中进行数据流的读取和写入。<code>FileStream</code> 类继承了 <code>Stream</code> 类，并实现了各种文件 I&#x2F;O 操作的具体细节。</p>
<p>当使用 <code>FileStream</code> 类进行文件操作时，通常会涉及创建、打开、读取、写入和关闭文件。下面是一些具体的示例，演示了如何使用 <code>FileStream</code> 类执行这些操作：</p>
<h3 id="FileStream创建文件并写入数据"><a href="#FileStream创建文件并写入数据" class="headerlink" title="FileStream创建文件并写入数据"></a>FileStream创建文件并写入数据</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> fileName = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> content = <span class="string">&quot;Hello, FileStream!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 FileStream 创建一个新文件，以写入方式打开</span></span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(fileName, FileMode.Create, FileAccess.Write))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将字符串内容转换为字节数组</span></span><br><span class="line">            <span class="built_in">byte</span>[] data = Encoding.UTF8.GetBytes(content);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将字节数组写入文件</span></span><br><span class="line">            fs.Write(data, <span class="number">0</span>, data.Length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;File created and data written successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileStream打开文件并读取数据"><a href="#FileStream打开文件并读取数据" class="headerlink" title="FileStream打开文件并读取数据"></a>FileStream打开文件并读取数据</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> fileName = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 FileStream 打开一个现有文件，以只读方式打开</span></span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(fileName, FileMode.Open, FileAccess.Read))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建一个缓冲区来存储读取的数据</span></span><br><span class="line">            <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从文件中读取数据到缓冲区中</span></span><br><span class="line">            <span class="built_in">int</span> bytesRead = fs.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将读取的字节数组转换为字符串并输出到控制台</span></span><br><span class="line">            <span class="built_in">string</span> data = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Data read from file: &quot;</span> + data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileStream追加数据到现有文件"><a href="#FileStream追加数据到现有文件" class="headerlink" title="FileStream追加数据到现有文件"></a>FileStream追加数据到现有文件</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> fileName = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> newData = <span class="string">&quot;\nAppending additional data.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 FileStream 打开一个现有文件，以追加方式打开</span></span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(fileName, FileMode.Append, FileAccess.Write))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将字符串内容转换为字节数组</span></span><br><span class="line">            <span class="built_in">byte</span>[] data = Encoding.UTF8.GetBytes(newData);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将字节数组写入文件</span></span><br><span class="line">            fs.Write(data, <span class="number">0</span>, data.Length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Additional data appended to file successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileStream删除现有文件"><a href="#FileStream删除现有文件" class="headerlink" title="FileStream删除现有文件"></a>FileStream删除现有文件</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> fileName = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查文件是否存在，如果存在则删除</span></span><br><span class="line">        <span class="keyword">if</span> (File.Exists(fileName))</span><br><span class="line">        &#123;</span><br><span class="line">            File.Delete(fileName);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;File deleted successfully.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;File does not exist.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些示例演示了如何使用 <code>FileStream</code> 类创建、打开、读取、写入和删除文件。记得在使用完毕后关闭文件流以释放资源，可以使用 <code>using</code> 语句确保在作用域结束时自动关闭文件流。</p>
<h3 id="StreamReader"><a href="#StreamReader" class="headerlink" title="StreamReader"></a>StreamReader</h3><p><code>StreamReader</code> 类的父类是 <code>TextReader</code>。<code>TextReader</code> 是一个抽象类，定义了读取字符流的基本方法和属性，而 <code>StreamReader</code> 则是实现了从字节流读取字符的具体类。</p>
<p><code>StreamReader</code> 是 .NET 中用于从流中读取文本数据的类之一。它提供了一种方便的方式来从文件流或其他文本输入流中读取字符或文本数据。</p>
<p><code>StreamReader</code> 类位于 <code>System.IO</code> 命名空间中，它包含了一系列用于读取文本的方法。你可以使用 <code>StreamReader</code> 来读取字符串、字符数组或者整行文本数据。常用的方法包括 <code>Read</code>、<code>ReadLine</code>、<code>ReadToEnd</code> 等。</p>
<p>下面是一个简单的示例，演示了如何使用 <code>StreamReader</code> 从文件中读取文本数据：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> filePath = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 StreamReader 读取文件中的文本</span></span><br><span class="line">        <span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(filePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们打开了一个名为 <code>example.txt</code> 的文件，并使用 <code>StreamReader</code> 逐行读取了文件中的文本数据，然后将每一行文本输出到控制台上。</p>
<h3 id="StreamWrite"><a href="#StreamWrite" class="headerlink" title="StreamWrite"></a>StreamWrite</h3><p><code>StreamReader</code> 类的父类是 <code>TextReader</code>。<code>TextReader</code> 是一个抽象类，定义了读取字符流的基本方法和属性，而 <code>StreamReader</code> 则是实现了从字节流读取字符的具体类。</p>
<p><code>StreamWriter</code> 是 .NET 中用于将文本写入流的类之一。它提供了一种方便的方式来将文本数据写入文件流或内存流等。<code>StreamWriter</code> 通常用于写入文本文件，但也可以用于其他文本输出流。</p>
<p><code>StreamWriter</code> 类位于 <code>System.IO</code> 命名空间中，它包含了一系列用于写入文本的方法。你可以使用 <code>StreamWriter</code> 来写入字符串、字符数组或者格式化的数据到流中。常用的方法包括 <code>Write</code>、<code>WriteLine</code>、<code>WriteAsync</code> 等。</p>
<p>下面是一个简单的示例，演示了如何使用 <code>StreamWriter</code> 将文本写入文件：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> filePath = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 StreamWriter 写入文本到文件</span></span><br><span class="line">        <span class="keyword">using</span> (StreamWriter writer = <span class="keyword">new</span> StreamWriter(filePath))</span><br><span class="line">        &#123;</span><br><span class="line">            writer.WriteLine(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">            writer.WriteLine(<span class="string">&quot;This is a test.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;文本已成功写入文件！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个名为 <code>example.txt</code> 的文件，并使用 <code>StreamWriter</code> 写入了两行文本到该文件中。运行程序后，你将在当前目录下找到生成的 <code>example.txt</code> 文件，并包含了写入的文本内容。</p>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p><code>File</code> 类是 <code>System.IO</code> 命名空间下的一个静态类，提供了一组用于操作文件的静态方法。使用 <code>File</code> 类，你可以执行诸如创建、复制、删除文件等操作。以下是 <code>File</code> 类的一些常用方法：</p>
<ol>
<li><p><strong>创建文件：</strong> <code>Create</code> 方法用于创建一个新的文件。如果文件已存在，则会被覆盖。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Create(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除文件：</strong> <code>Delete</code> 方法用于删除指定的文件。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Delete(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复制文件：</strong> <code>Copy</code> 方法用于将文件复制到新位置。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Copy(<span class="string">@&quot;C:\SourceFile.txt&quot;</span>, <span class="string">@&quot;D:\DestinationFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果想要覆盖目标文件，可以设置第三个参数为 <code>true</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Copy(<span class="string">@&quot;C:\SourceFile.txt&quot;</span>, <span class="string">@&quot;D:\DestinationFile.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>移动文件：</strong> <code>Move</code> 方法用于将文件移动到新位置。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.Move(<span class="string">@&quot;C:\SourceFile.txt&quot;</span>, <span class="string">@&quot;D:\NewLocation\SourceFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查文件是否存在：</strong> <code>Exists</code> 方法用于检查指定的文件是否存在。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (File.Exists(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 文件存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>读取文件内容：</strong> <code>ReadAllText</code> 和 <code>ReadAllLines</code> 方法用于读取文件的内容。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> text = File.ReadAllText(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>[] lines = File.ReadAllLines(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>写入文件内容：</strong> <code>WriteAllText</code> 和 <code>WriteAllLines</code> 方法用于向文件中写入内容。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File.WriteAllText(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>[] lines = &#123; <span class="string">&quot;Line 1&quot;</span>, <span class="string">&quot;Line 2&quot;</span>, <span class="string">&quot;Line 3&quot;</span> &#125;;</span><br><span class="line">File.WriteAllLines(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>, lines);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取文件的创建时间、访问时间和修改时间：</strong> <code>GetCreationTime</code>、<code>GetLastAccessTime</code> 和 <code>GetLastWriteTime</code> 方法用于获取文件的创建时间、访问时间和修改时间。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTime creationTime = File.GetCreationTime(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>);</span><br><span class="line">DateTime lastAccessTime = File.GetLastAccessTime(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>);</span><br><span class="line">DateTime lastWriteTime = File.GetLastWriteTime(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置文件的创建时间、访问时间和修改时间：</strong> <code>SetCreationTime</code>、<code>SetLastAccessTime</code> 和 <code>SetLastWriteTime</code> 方法用于设置文件的创建时间、访问时间和修改时间。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File.SetCreationTime(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>, DateTime.Now);</span><br><span class="line">File.SetLastAccessTime(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>, DateTime.Now);</span><br><span class="line">File.SetLastWriteTime(<span class="string">@&quot;C:\ExampleFile.txt&quot;</span>, DateTime.Now);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方法提供了对文件进行各种操作的便捷方式，可以方便地管理文件系统中的文件。</p>
<h3 id="Directory类"><a href="#Directory类" class="headerlink" title="Directory类"></a>Directory类</h3><p><code>Directory</code> 类是 <code>System.IO</code> 命名空间下的一个静态类，提供了一组用于操作目录的静态方法。使用 <code>Directory</code> 类，你可以执行诸如创建、移动、删除目录等操作。以下是 <code>Directory</code> 类的一些常用方法：</p>
<ol>
<li><p><strong>创建目录：</strong> <code>CreateDirectory</code> 方法用于创建一个新的目录。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory.CreateDirectory(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除目录：</strong> <code>Delete</code> 方法用于删除指定的目录。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory.Delete(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果目录不为空，可以使用第二个参数来指定是否递归删除子目录和文件：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory.Delete(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查目录是否存在：</strong> <code>Exists</code> 方法用于检查指定的目录是否存在。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Directory.Exists(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 目录存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取目录中的文件和子目录列表：</strong> <code>GetFiles</code> 和 <code>GetDirectories</code> 方法用于获取指定目录中的文件和子目录列表。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] files = Directory.GetFiles(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>[] directories = Directory.GetDirectories(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>移动目录：</strong> <code>Move</code> 方法用于将指定目录移动到新位置。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory.Move(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>, <span class="string">@&quot;D:\NewDirectory&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取目录的创建时间、访问时间和修改时间：</strong> <code>GetCreationTime</code>、<code>GetLastAccessTime</code> 和 <code>GetLastWriteTime</code> 方法用于获取目录的创建时间、访问时间和修改时间。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTime creationTime = Directory.GetCreationTime(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>);</span><br><span class="line">DateTime lastAccessTime = Directory.GetLastAccessTime(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>);</span><br><span class="line">DateTime lastWriteTime = Directory.GetLastWriteTime(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置目录的创建时间、访问时间和修改时间：</strong> <code>SetCreationTime</code>、<code>SetLastAccessTime</code> 和 <code>SetLastWriteTime</code> 方法用于设置目录的创建时间、访问时间和修改时间。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Directory.SetCreationTime(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>, DateTime.Now);</span><br><span class="line">Directory.SetLastAccessTime(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>, DateTime.Now);</span><br><span class="line">Directory.SetLastWriteTime(<span class="string">@&quot;C:\ExampleDirectory&quot;</span>, DateTime.Now);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方法提供了对目录进行各种操作的便捷方式，可以方便地管理文件系统中的目录结构。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>C# 的 I&#x2F;O 流提供了丰富的功能和灵活的接口，用于实现各种类型的 I&#x2F;O 操作。通过合理地选择和使用不同的流类，可以轻松地处理文件、内存、网络等数据源，从而实现程序的各种需求。在实际开发中，要根据具体的需求和场景选择合适的流类，并注意及时释放资源以避免资源泄漏。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>在 C# 中，序列化是将对象转换为可以存储或传输的格式的过程，而反序列化则是将序列化后的数据重新转换为对象的过程。C# 提供了多种序列化和反序列化的方式，包括二进制序列化、XML 序列化和 JSON 序列化等。</p>
<h3 id="二进制序列化"><a href="#二进制序列化" class="headerlink" title="二进制序列化"></a>二进制序列化</h3><p>二进制序列化是将对象转换为二进制格式的过程，可以将对象写入到文件中或通过网络传输。C# 中的二进制序列化通常使用 <code>BinaryFormatter</code> 类来实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Person 对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Alice&quot;</span>, Age = <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 BinaryFormatter 对象</span></span><br><span class="line">        BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件流</span></span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;person.dat&quot;</span>, FileMode.Create))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将对象序列化到文件中</span></span><br><span class="line">            formatter.Serialize(fs, person);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Serialization complete.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二进制反序列化"><a href="#二进制反序列化" class="headerlink" title="二进制反序列化"></a>二进制反序列化</h3><p>反序列化是将序列化后的数据重新转换为对象的过程。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建 BinaryFormatter 对象</span></span><br><span class="line">        BinaryFormatter formatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件流</span></span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;person.dat&quot;</span>, FileMode.Open))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从文件中反序列化对象</span></span><br><span class="line">            Person person = (Person)formatter.Deserialize(fs);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;person.Name&#125;</span>, Age: <span class="subst">&#123;person.Age&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Deserialization complete.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="XML序列化"><a href="#XML序列化" class="headerlink" title="XML序列化"></a>XML序列化</h3><p>XML 序列化是将对象转换为 XML 格式的过程，通常用于在不同平台之间传输对象。C# 中的 XML 序列化通常使用 <code>XmlSerializer</code> 类来实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Person 对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Bob&quot;</span>, Age = <span class="number">25</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 XmlSerializer 对象</span></span><br><span class="line">        XmlSerializer serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(Person));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件流</span></span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;person.xml&quot;</span>, FileMode.Create))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将对象序列化为 XML 格式并写入文件</span></span><br><span class="line">            serializer.Serialize(fs, person);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Serialization complete.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XML反序列化"><a href="#XML反序列化" class="headerlink" title="XML反序列化"></a>XML反序列化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建 XmlSerializer 对象</span></span><br><span class="line">        XmlSerializer serializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(Person));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件流</span></span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(<span class="string">&quot;person.xml&quot;</span>, FileMode.Open))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从文件中反序列化对象</span></span><br><span class="line">            Person person = (Person)serializer.Deserialize(fs);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;person.Name&#125;</span>, Age: <span class="subst">&#123;person.Age&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Deserialization complete.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON-序列化"><a href="#JSON-序列化" class="headerlink" title="JSON 序列化"></a>JSON 序列化</h3><p>JSON 序列化是将对象转换为 JSON 格式的过程，通常用于在 Web 应用程序中传输数据。C# 中的 JSON 序列化通常使用第三方库，如 Newtonsoft.Json。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Person 对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Alice&quot;</span>, Age = <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对象序列化为 JSON 字符串</span></span><br><span class="line">        <span class="built_in">string</span> json = JsonConvert.SerializeObject(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 JSON 字符串写入文件</span></span><br><span class="line">        File.WriteAllText(<span class="string">&quot;person.json&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Serialization complete.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON-反序列化"><a href="#JSON-反序列化" class="headerlink" title="JSON 反序列化"></a>JSON 反序列化</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可序列化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从文件中读取 JSON 字符串</span></span><br><span class="line">        <span class="built_in">string</span> json = File.ReadAllText(<span class="string">&quot;person.json&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 JSON 字符串反序列化为对象</span></span><br><span class="line">        Person person = JsonConvert.DeserializeObject&lt;Person&gt;(json);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;person.Name&#125;</span>, Age: <span class="subst">&#123;person.Age&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Deserialization complete.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是在 C# 中进行序列化和反序列化的一般方法。根据具体的需求和场景，可以选择合适的序列化方式和相关库来实现对象的序列化和反序列化。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>C# 中的反射（Reflection）是指在运行时动态地获取类型信息、成员信息和调用成员的能力。反射使得程序能够在运行时查询和操作类型、对象和成员，而不需要事先知道它们的具体信息。</p>
<h3 id="主要的反射类"><a href="#主要的反射类" class="headerlink" title="主要的反射类"></a>主要的反射类</h3><p>在 C# 中，反射主要通过 <code>System.Reflection</code> 命名空间中的类来实现。</p>
<ol>
<li><p><strong>Assembly（程序集）：</strong> 表示一个已加载到应用程序域中的程序集，可以获取程序集的元数据信息，如类型、成员等。</p>
</li>
<li><p><strong>Type（类型）：</strong> 表示一个类、结构、接口、枚举或委托类型，可以获取类型的成员信息，如字段、属性、方法等。</p>
</li>
<li><p><strong>MethodInfo（方法信息）：</strong> 表示类中的方法，可以获取方法的参数、返回值等信息，并调用方法。</p>
</li>
<li><p><strong>FieldInfo（字段信息）：</strong> 表示类中的字段，可以获取字段的类型、值等信息，并设置字段的值。</p>
</li>
<li><p><strong>PropertyInfo（属性信息）：</strong> 表示类中的属性，可以获取属性的类型、值等信息，并设置属性的值。</p>
</li>
<li><p><strong>EventInfo（事件信息）：</strong> 表示类中的事件，可以获取事件的类型、订阅和取消订阅事件等信息。</p>
</li>
</ol>
<h3 id="使用反射的场景"><a href="#使用反射的场景" class="headerlink" title="使用反射的场景"></a>使用反射的场景</h3><ol>
<li><p><strong>动态加载程序集：</strong> 在运行时根据需要加载程序集，而不是在编译时将所有程序集都引入。</p>
</li>
<li><p><strong>动态创建对象：</strong> 根据类型信息创建对象，而不需要显式调用构造函数。</p>
</li>
<li><p><strong>动态调用方法：</strong> 根据方法信息调用对象的方法，而不需要提前知道方法名称。</p>
</li>
<li><p><strong>动态访问和修改成员：</strong> 获取和设置对象的字段和属性的值，动态调用事件等。</p>
</li>
</ol>
<h3 id="示例：使用反射获取类型信息和成员信息"><a href="#示例：使用反射获取类型信息和成员信息" class="headerlink" title="示例：使用反射获取类型信息和成员信息"></a>示例：使用反射获取类型信息和成员信息</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取程序集信息</span></span><br><span class="line">        Assembly assembly = Assembly.GetExecutingAssembly();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取类型信息</span></span><br><span class="line">        Type type = assembly.GetType(<span class="string">&quot;MyNamespace.MyClass&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取类型的字段信息</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fields:&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> field <span class="keyword">in</span> type.GetFields())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;field.Name&#125;</span>: <span class="subst">&#123;field.FieldType&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取类型的属性信息</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Properties:&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> type.GetProperties())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;prop.Name&#125;</span>: <span class="subst">&#123;prop.PropertyType&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取类型的方法信息</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Methods:&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> method <span class="keyword">in</span> type.GetMethods())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;method.Name&#125;</span>: <span class="subst">&#123;method.ReturnType&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> MyField;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> MyProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyMethod</span>()</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例演示了如何使用反射获取程序集、类型、字段、属性和方法的信息。通过反射，可以在运行时动态地探索和操作类型的成员，从而实现更加灵活和动态的编程。但是需要注意，反射的使用可能会导致性能下降，并且使代码更加复杂，因此应该谨慎使用。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程是指在单个进程中同时执行多个线程的编程模型。在 C# 中，多线程编程可以通过 <code>System.Threading</code> 命名空间中的类和方法来实现。下面是一些关于多线程的基本概念和常用方法：</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p><strong>线程（Thread）：</strong> 线程是执行程序代码的基本单元，每个线程都有自己的执行路径和执行上下文，可以独立运行。</p>
</li>
<li><p><strong>进程（Process）：</strong> 进程是程序的一个实例，在操作系统中具有独立的内存空间和系统资源，可以包含一个或多个线程。</p>
</li>
<li><p><strong>多线程（Multithreading）：</strong> 多线程是指在同一个进程中同时执行多个线程，每个线程可以独立执行不同的任务。</p>
</li>
<li><p><strong>并发（Concurrency）：</strong> 并发是指多个线程在同一时间段内执行，可以提高系统的吞吐量和响应速度。</p>
</li>
<li><p><strong>互斥（Mutual Exclusion）：</strong> 互斥是一种同步机制，用于保护共享资源，防止多个线程同时访问和修改。</p>
</li>
<li><p><strong>同步（Synchronization）：</strong> 同步是一种协调机制，用于控制线程的执行顺序和互斥访问共享资源。</p>
</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li><p><strong>创建线程：</strong> 使用 <code>Thread</code> 类来创建和管理线程，可以通过构造函数传递一个委托（通常是 <code>ThreadStart</code> 委托或 <code>ParameterizedThreadStart</code> 委托）来指定线程要执行的方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(MyThreadMethod);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动线程：</strong> 使用 <code>Start</code> 方法来启动线程，使其开始执行指定的方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.Start();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程休眠：</strong> 使用 <code>Thread.Sleep</code> 方法来使当前线程休眠指定的时间。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 休眠1秒钟</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程加入：</strong> 使用 <code>Join</code> 方法来等待一个线程完成执行。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.Join(); <span class="comment">// 等待线程执行完毕</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程终止：</strong> 使用 <code>Abort</code> 方法来强制终止一个线程的执行。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.Abort(); <span class="comment">// 终止线程的执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程池：</strong> 使用 <code>ThreadPool</code> 类来管理线程池，可以减少线程创建和销毁的开销。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(MyThreadMethod); <span class="comment">// 将方法添加到线程池中执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异步方法：</strong> .Net 5.0 中使用 <code>async</code> 和 <code>await</code> 关键字来定义异步方法，可以在不阻塞主线程的情况下执行耗时操作。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">MyAsyncMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>); <span class="comment">// 异步等待1秒钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程同步：</strong> 使用 <code>lock</code> 关键字或 <code>Monitor</code> 类来实现线程同步和互斥。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> (lockObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="CancellationToken"><a href="#CancellationToken" class="headerlink" title="CancellationToken"></a>CancellationToken</h3><p>以上是一些基本的多线程概念和常用方法，多线程编程涉及到很多复杂的概念和技术，需要谨慎使用并注意线程安全性。</p>
<p>在C#中，可以通过调用 <code>Thread.Abort()</code> 方法来中断线程。这会引发 <code>ThreadAbortException</code>，如果线程没有处理此异常，线程将被中止。然而，使用 <code>Thread.Abort()</code> 方法来中断线程是一个比较粗暴的方法，因为它可能导致资源泄漏或不一致的状态。更好的方法是通过使用 <code>CancellationToken</code> 来请求取消操作，以便线程可以在合适的时候优雅地退出。</p>
<p>以下是使用 <code>Thread.Abort()</code> 方法中断线程的示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(DoWork);</span><br><span class="line">        thread.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在一定时间后中断线程</span></span><br><span class="line">        Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">        thread.Abort();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Thread has been aborted.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoWork</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Working...&quot;</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 模拟一些工作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ThreadAbortException)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Thread has been aborted.&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行清理工作（如果有）</span></span><br><span class="line">            <span class="comment">// 最后，调用 Thread.ResetAbort() 方法来清除线程的中断请求</span></span><br><span class="line">            Thread.ResetAbort();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，虽然使用 <code>Thread.Abort()</code> 方法可以中断线程，但是它不太安全，因为它可能会导致线程在不恰当的时间点终止，从而可能导致资源泄漏或不一致的状态。因此，更推荐的做法是使用 <code>CancellationToken</code> 来请求取消操作，让线程在适当的时候自行退出。</p>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>在.Net 4.0中基于ThreadPool的基础上封装的对象</p>
<p>Task解决了手动创建Thread线程带来的损耗，又解决了ThreadPool不能对单个</p>
<p>Action是一个委托，是一个无参无返回值的委托</p>
<p>start 可以带参数，带返回值</p>
<p>run 用的比较多，可以创建并运行，不好带参数，可以带返回值</p>
<h2 id="C-3-0中新语法"><a href="#C-3-0中新语法" class="headerlink" title="C#3.0中新语法"></a>C#3.0中新语法</h2><h3 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h3><p>在编译时自动生成对应的私有字段</p>
<h3 id="对象初始化器和集合初始化器"><a href="#对象初始化器和集合初始化器" class="headerlink" title="对象初始化器和集合初始化器"></a>对象初始化器和集合初始化器</h3><h3 id="隐式类型变量Var"><a href="#隐式类型变量Var" class="headerlink" title="隐式类型变量Var"></a>隐式类型变量Var</h3><p>在编译时根据上下文推断出变量的类型</p>
<ul>
<li>只能定义为局部变量</li>
<li>对象初始化器和集合初始化器</li>
<li>使用var声明的变量是强类型变量</li>
</ul>
<h3 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h3><p>在行内声明类型，而不是正式定义一个类</p>
<h3 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h3><p>对于原来的类型，拓展出新的功能</p>
<ul>
<li>拓展方法定义在静态类中</li>
<li>拓展方法定义成静态方法</li>
<li>拓展方法的第一个参数始终是this 类型 实例</li>
</ul>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 表达式是一种匿名函数，可以包含表达式和语句，并且可以用于创建委托或表达式树类型。Lambda 表达式使用 <code>=&gt;</code> 运算符，运算符左侧是输入参数，右侧是表达式或语句块。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) =&gt; expression</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (x, y) =&gt; x + y;</span><br><span class="line">Console.WriteLine(<span class="keyword">add</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式过滤列表</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>).ToList();</span><br></pre></td></tr></table></figure>

<h3 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h3><p>表达式树（Expression Trees）是 Lambda 表达式的一种特殊形式，可以在运行时动态创建和执行代码。表达式树表示代码结构，并可以用于 LINQ 提供程序，如 LINQ to SQL。</p>
<h4 id="创建表达式树"><a href="#创建表达式树" class="headerlink" title="创建表达式树"></a>创建表达式树</h4><p>表达式树是由 <code>System.Linq.Expressions</code> 命名空间中的类表示的。可以使用 <code>Expression</code> 类来创建表达式树。</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq.Expressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个表达式树：表达式表示 x =&gt; x * 2</span></span><br><span class="line">        Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; expr = x =&gt; x * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译表达式树到可执行代码</span></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; compiledExpr = expr.Compile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行表达式</span></span><br><span class="line">        <span class="built_in">int</span> result = compiledExpr(<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(result);  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印表达式树结构</span></span><br><span class="line">        Console.WriteLine(expr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Expression&lt;Func&lt;int, int&gt;&gt; expr = x =&gt; x * 2;</code> 创建了一个表达式树，表示一个输入为 <code>int</code>，输出为 <code>int</code> 的函数。然后使用 <code>Compile</code> 方法将表达式树编译为可执行代码，并执行。</p>
<h3 id="Lambda-表达式详细解析"><a href="#Lambda-表达式详细解析" class="headerlink" title="Lambda 表达式详细解析"></a>Lambda 表达式详细解析</h3><h4 id="1-单参数Lambda表达式"><a href="#1-单参数Lambda表达式" class="headerlink" title="1. 单参数Lambda表达式"></a>1. 单参数Lambda表达式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square = x =&gt; x * <span class="number">2</span>;</span><br><span class="line">Console.WriteLine(square(<span class="number">5</span>));  <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>x =&gt; x * 2</code> 是一个 Lambda 表达式，接收一个参数 <code>x</code>，并返回 <code>x * 2</code>。</p>
<h4 id="2-多参数Lambda表达式"><a href="#2-多参数Lambda表达式" class="headerlink" title="2. 多参数Lambda表达式"></a>2. 多参数Lambda表达式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (x, y) =&gt; x + y;</span><br><span class="line">Console.WriteLine(<span class="keyword">add</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，Lambda 表达式 <code>(x, y) =&gt; x + y</code> 接收两个参数 <code>x</code> 和 <code>y</code>，并返回它们的和。</p>
<h4 id="3-没有参数的Lambda表达式"><a href="#3-没有参数的Lambda表达式" class="headerlink" title="3. 没有参数的Lambda表达式"></a>3. 没有参数的Lambda表达式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action greet = () =&gt; Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">greet();  <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里的 Lambda 表达式 <code>() =&gt; Console.WriteLine(&quot;Hello, World!&quot;)</code> 不接收任何参数，并打印一条消息。</p>
<h4 id="4-具有语句块的Lambda表达式"><a href="#4-具有语句块的Lambda表达式" class="headerlink" title="4. 具有语句块的Lambda表达式"></a>4. 具有语句块的Lambda表达式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; addAndMultiply = (x, y) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine(addAndMultiply(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，Lambda 表达式包含一个语句块 <code>&#123; ... &#125;</code>，可以包含多个语句。</p>
<h3 id="表达式树详细解析"><a href="#表达式树详细解析" class="headerlink" title="表达式树详细解析"></a>表达式树详细解析</h3><h4 id="1-创建简单的表达式树"><a href="#1-创建简单的表达式树" class="headerlink" title="1. 创建简单的表达式树"></a>1. 创建简单的表达式树</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq.Expressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建表达式树：表示 x =&gt; x + 1</span></span><br><span class="line">        ParameterExpression param = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;x&quot;</span>);</span><br><span class="line">        ConstantExpression constant = Expression.Constant(<span class="number">1</span>);</span><br><span class="line">        BinaryExpression body = Expression.Add(param, constant);</span><br><span class="line">        Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt;(body, param);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译并执行表达式树</span></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; compiledExpr = expr.Compile();</span><br><span class="line">        <span class="built_in">int</span> result = compiledExpr(<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(result);  <span class="comment">// 输出 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们手动构建了一棵表达式树，表示 <code>x =&gt; x + 1</code>，并编译和执行它。</p>
<h4 id="2-分析复杂表达式树"><a href="#2-分析复杂表达式树" class="headerlink" title="2. 分析复杂表达式树"></a>2. 分析复杂表达式树</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq.Expressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表达式树：表示 (x, y) =&gt; x * y + 2</span></span><br><span class="line">        ParameterExpression param1 = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;x&quot;</span>);</span><br><span class="line">        ParameterExpression param2 = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;y&quot;</span>);</span><br><span class="line">        ConstantExpression constant = Expression.Constant(<span class="number">2</span>);</span><br><span class="line">        BinaryExpression multiply = Expression.Multiply(param1, param2);</span><br><span class="line">        BinaryExpression body = Expression.Add(multiply, constant);</span><br><span class="line">        Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; expr = Expression.Lambda&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt;(body, param1, param2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译并执行表达式树</span></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; compiledExpr = expr.Compile();</span><br><span class="line">        <span class="built_in">int</span> result = compiledExpr(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        Console.WriteLine(result);  <span class="comment">// 输出 14</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们构建了一个表示 <code>(x, y) =&gt; x * y + 2</code> 的表达式树，并编译和执行它。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Lambda 表达式和表达式树是 C# 中非常强大的功能，允许开发人员编写简洁的内联代码，并在运行时动态生成和执行代码。Lambda 表达式主要用于简化委托的使用，而表达式树则用于构建动态查询和代码生成场景。</p>
<p>如果您有更多具体问题或更详细的需求，请提供更多上下文，我将更具体地回答您的问题。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/CSS/" rel="prev" title="CSS">
                  <i class="fa fa-angle-left"></i> CSS
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/WinForm/" rel="next" title="WinForm">
                  WinForm <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
